<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libevent Code Doxygen document: include/event2/event.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Libevent Code Doxygen document
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_950215895bb29e6452853960814ef572.html">event2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">event.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/visibility.h&gt;</code><br />
<code>#include &lt;event2/event-config.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for event.h:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h__incl.png" border="0" usemap="#ainclude_2event2_2event_8h" alt=""/></div>
<map name="ainclude_2event2_2event_8h" id="ainclude_2event2_2event_8h">
<area shape="rect" title=" " alt="" coords="40,5,210,32"/>
<area shape="rect" href="visibility_8h_source.html" title=" " alt="" coords="22,155,159,181"/>
<area shape="rect" href="event-config_8h_source.html" title=" " alt="" coords="8,229,172,256"/>
<area shape="rect" title=" " alt="" coords="128,80,194,107"/>
<area shape="rect" href="util_8h.html" title=" " alt="" coords="254,80,358,107"/>
<area shape="rect" title=" " alt="" coords="449,155,524,181"/>
<area shape="rect" title=" " alt="" coords="183,155,286,181"/>
<area shape="rect" title=" " alt="" coords="310,155,374,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h__dep__incl.png" border="0" usemap="#ainclude_2event2_2event_8hdep" alt=""/></div>
<map name="ainclude_2event2_2event_8hdep" id="ainclude_2event2_2event_8hdep">
<area shape="rect" title=" " alt="" coords="309,5,479,32"/>
<area shape="rect" href="event_8h.html" title=" " alt="" coords="155,80,278,107"/>
<area shape="rect" href="listener_8h_source.html" title=" " alt="" coords="303,80,485,107"/>
<area shape="rect" href="minheap-internal_8h_source.html" title=" " alt="" coords="510,80,657,107"/>
<area shape="rect" href="evdns_8h.html" title=" " alt="" coords="5,155,129,181"/>
<area shape="rect" href="evhttp_8h.html" title=" " alt="" coords="153,155,280,181"/>
<area shape="rect" href="evrpc_8h.html" title=" " alt="" coords="304,155,425,181"/>
<area shape="rect" href="event-internal_8h_source.html" title=" " alt="" coords="520,155,647,181"/>
</map>
</div>
</div>
<p><a href="event2_2event_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a964443418439acdd775129ae260b21bb"><td class="memItemLeft" align="right" valign="top"><a id="a964443418439acdd775129ae260b21bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_DEBUG</b>&#160;&#160;&#160;EVENT_LOG_DEBUG</td></tr>
<tr class="separator:a964443418439acdd775129ae260b21bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d898badc07a518c29ecb0129cc77188"><td class="memItemLeft" align="right" valign="top"><a id="a6d898badc07a518c29ecb0129cc77188"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_MSG</b>&#160;&#160;&#160;EVENT_LOG_MSG</td></tr>
<tr class="separator:a6d898badc07a518c29ecb0129cc77188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ba4ffdc827c139311654c41cfddd1d"><td class="memItemLeft" align="right" valign="top"><a id="aa8ba4ffdc827c139311654c41cfddd1d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_WARN</b>&#160;&#160;&#160;EVENT_LOG_WARN</td></tr>
<tr class="separator:aa8ba4ffdc827c139311654c41cfddd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829eede32e73952922a35e42b510bfe9"><td class="memItemLeft" align="right" valign="top"><a id="a829eede32e73952922a35e42b510bfe9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_ERR</b>&#160;&#160;&#160;EVENT_LOG_ERR</td></tr>
<tr class="separator:a829eede32e73952922a35e42b510bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba29ef7ed0ed9e0f55737f636f8cde7"><td class="memItemLeft" align="right" valign="top"><a id="a2ba29ef7ed0ed9e0f55737f636f8cde7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_DBG_ALL</b>&#160;&#160;&#160;0xffffffffu</td></tr>
<tr class="separator:a2ba29ef7ed0ed9e0f55737f636f8cde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c72c789b7c7905ea19592cf878b0744"><td class="memItemLeft" align="right" valign="top"><a id="a0c72c789b7c7905ea19592cf878b0744"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_DBG_NONE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a0c72c789b7c7905ea19592cf878b0744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc368a9137187726ef371a06f9cc9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a69cc368a9137187726ef371a06f9cc9f">event_get_signal</a>(ev)&#160;&#160;&#160;((int)<a class="el" href="event2_2event_8h.html#a4f63589ebe3e0d4c9e20447f96d343b2">event_get_fd</a>(ev))</td></tr>
<tr class="separator:a69cc368a9137187726ef371a06f9cc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad00c7d4ddbd6b590c15861a2e767182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aad00c7d4ddbd6b590c15861a2e767182">LIBEVENT_VERSION</a>&#160;&#160;&#160;EVENT__VERSION</td></tr>
<tr class="separator:aad00c7d4ddbd6b590c15861a2e767182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9c8021651a2d8d7946083281279586"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a8a9c8021651a2d8d7946083281279586">LIBEVENT_VERSION_NUMBER</a>&#160;&#160;&#160;EVENT__NUMERIC_VERSION</td></tr>
<tr class="separator:a8a9c8021651a2d8d7946083281279586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74f7bf73ff985bfaf61c462cbba022f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ad74f7bf73ff985bfaf61c462cbba022f">EVENT_MAX_PRIORITIES</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ad74f7bf73ff985bfaf61c462cbba022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade387a9a39bbbdf40ff20b4d977ec6ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ade387a9a39bbbdf40ff20b4d977ec6ae">EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED</a></td></tr>
<tr class="separator:ade387a9a39bbbdf40ff20b4d977ec6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">event type flag</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Flags to pass to <a class="el" href="event2_2event_8h.html#afcbf68a9eaf33ff684c01e26e25c0d7d">event_base_get_num_events()</a> to specify the kinds of events we want to aggregate counts for </p>
</div></td></tr>
<tr class="memitem:aa3786406bc592990f0583ac211110fa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aa3786406bc592990f0583ac211110fa3">EVENT_BASE_COUNT_ACTIVE</a>&#160;&#160;&#160;1U</td></tr>
<tr class="separator:aa3786406bc592990f0583ac211110fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4e49b51ffe924451c9048c5061a224"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aac4e49b51ffe924451c9048c5061a224">EVENT_BASE_COUNT_VIRTUAL</a>&#160;&#160;&#160;2U</td></tr>
<tr class="separator:aac4e49b51ffe924451c9048c5061a224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36205e544778da7d91ec8555b962851a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a36205e544778da7d91ec8555b962851a">EVENT_BASE_COUNT_ADDED</a>&#160;&#160;&#160;4U</td></tr>
<tr class="separator:a36205e544778da7d91ec8555b962851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log severities</div></td></tr>
<tr class="memitem:a6904203c125cd86cdd4f3cd90ef1c18f"><td class="memItemLeft" align="right" valign="top"><a id="a6904203c125cd86cdd4f3cd90ef1c18f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_DEBUG</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a6904203c125cd86cdd4f3cd90ef1c18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18003965fc4df307a68d4f5bde2ec45"><td class="memItemLeft" align="right" valign="top"><a id="ae18003965fc4df307a68d4f5bde2ec45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_MSG</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ae18003965fc4df307a68d4f5bde2ec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795675e9eb8d63782e86260f101ae72d"><td class="memItemLeft" align="right" valign="top"><a id="a795675e9eb8d63782e86260f101ae72d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_WARN</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a795675e9eb8d63782e86260f101ae72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51b4412fec9223efc5e5fa862b57a11"><td class="memItemLeft" align="right" valign="top"><a id="ab51b4412fec9223efc5e5fa862b57a11"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_ERR</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ab51b4412fec9223efc5e5fa862b57a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loop flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags control the behavior of <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a>. </p>
</div></td></tr>
<tr class="memitem:afab575b1e867dde13a2c7f2f967e0e4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#afab575b1e867dde13a2c7f2f967e0e4e">EVLOOP_ONCE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:afab575b1e867dde13a2c7f2f967e0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9c102337d0ece8607c9c01bc4f7c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a10b9c102337d0ece8607c9c01bc4f7c8">EVLOOP_NONBLOCK</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a10b9c102337d0ece8607c9c01bc4f7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6751a7d5867ff8e7807400a93ffd5b08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a6751a7d5867ff8e7807400a93ffd5b08">EVLOOP_NO_EXIT_ON_EMPTY</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a6751a7d5867ff8e7807400a93ffd5b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">event flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Flags to pass to <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>, <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a>, <a class="el" href="event2_2event_8h.html#a9b1687396305898af018c74e63486eb5">event_pending()</a>, and anything else with an argument of the form "short events" </p>
</div></td></tr>
<tr class="memitem:a37ef4b6056484f5580f7d72fcf46fccf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a37ef4b6056484f5580f7d72fcf46fccf">EV_TIMEOUT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a37ef4b6056484f5580f7d72fcf46fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bbaf2d529670cc0ab793497b41700f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a74bbaf2d529670cc0ab793497b41700f">EV_READ</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a74bbaf2d529670cc0ab793497b41700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a31813fa3b26bf2d150512cbbf893f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a2a31813fa3b26bf2d150512cbbf893f7">EV_WRITE</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a2a31813fa3b26bf2d150512cbbf893f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7e95284ac1a197969d42ee9441ece"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a59b7e95284ac1a197969d42ee9441ece">EV_SIGNAL</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:a59b7e95284ac1a197969d42ee9441ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4947a60eb6d09327c61f89135f9f37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a3c4947a60eb6d09327c61f89135f9f37">EV_PERSIST</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a3c4947a60eb6d09327c61f89135f9f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01084abbcdd3a58b4068359548a3ea71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a01084abbcdd3a58b4068359548a3ea71">EV_ET</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:a01084abbcdd3a58b4068359548a3ea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac062d75b2bf9a961d893e3a71726bdff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ac062d75b2bf9a961d893e3a71726bdff">EV_FINALIZE</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:ac062d75b2bf9a961d893e3a71726bdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f643f9c9063a4cbf410f519eb61e55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a98f643f9c9063a4cbf410f519eb61e55">EV_CLOSED</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:a98f643f9c9063a4cbf410f519eb61e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">evtimer_* macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Aliases for working with one-shot timer events If you need EV_PERSIST timer use event_*() functions. </p>
</div></td></tr>
<tr class="memitem:a356b4550edd470440efa7a74da413939"><td class="memItemLeft" align="right" valign="top"><a id="a356b4550edd470440efa7a74da413939"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_assign</b>(ev,  b,  cb,  arg)&#160;&#160;&#160;	<a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign</a>((ev), (b), -1, 0, (cb), (arg))</td></tr>
<tr class="separator:a356b4550edd470440efa7a74da413939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b701417f1cd29208019283d1fd1691"><td class="memItemLeft" align="right" valign="top"><a id="a76b701417f1cd29208019283d1fd1691"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_new</b>(b,  cb,  arg)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new</a>((b), -1, 0, (cb), (arg))</td></tr>
<tr class="separator:a76b701417f1cd29208019283d1fd1691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea3ca87057c66fd9f5a9fda9b911f8b"><td class="memItemLeft" align="right" valign="top"><a id="a6ea3ca87057c66fd9f5a9fda9b911f8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_add</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add</a>((ev), (tv))</td></tr>
<tr class="separator:a6ea3ca87057c66fd9f5a9fda9b911f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f7e7b422e9098d9362626d47b77525"><td class="memItemLeft" align="right" valign="top"><a id="a22f7e7b422e9098d9362626d47b77525"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_del</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del</a>(ev)</td></tr>
<tr class="separator:a22f7e7b422e9098d9362626d47b77525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7037bae3f2fb09eb2752e8252b63a5a6"><td class="memItemLeft" align="right" valign="top"><a id="a7037bae3f2fb09eb2752e8252b63a5a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_pending</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a9b1687396305898af018c74e63486eb5">event_pending</a>((ev), <a class="el" href="event2_2event_8h.html#a37ef4b6056484f5580f7d72fcf46fccf">EV_TIMEOUT</a>, (tv))</td></tr>
<tr class="separator:a7037bae3f2fb09eb2752e8252b63a5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c62ada275b4114ca0494e9d1f0047"><td class="memItemLeft" align="right" valign="top"><a id="a765c62ada275b4114ca0494e9d1f0047"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_initialized</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a85b94b111b8aa7fb480fc2f9da7f8e18">event_initialized</a>(ev)</td></tr>
<tr class="separator:a765c62ada275b4114ca0494e9d1f0047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">evsignal_* macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Aliases for working with signal events </p>
</div></td></tr>
<tr class="memitem:a043e61907ad2ae55d61f5c5e109729dd"><td class="memItemLeft" align="right" valign="top"><a id="a043e61907ad2ae55d61f5c5e109729dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evsignal_add</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add</a>((ev), (tv))</td></tr>
<tr class="separator:a043e61907ad2ae55d61f5c5e109729dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eae4d05e8e104b1d72bb73eaf95da4"><td class="memItemLeft" align="right" valign="top"><a id="a08eae4d05e8e104b1d72bb73eaf95da4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evsignal_assign</b>(ev,  b,  x,  cb,  arg)&#160;&#160;&#160;	<a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign</a>((ev), (b), (x), <a class="el" href="event2_2event_8h.html#a59b7e95284ac1a197969d42ee9441ece">EV_SIGNAL</a>|<a class="el" href="event2_2event_8h.html#a3c4947a60eb6d09327c61f89135f9f37">EV_PERSIST</a>, cb, (arg))</td></tr>
<tr class="separator:a08eae4d05e8e104b1d72bb73eaf95da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990ce36ac02fb1033a0cc56df968b4c4"><td class="memItemLeft" align="right" valign="top"><a id="a990ce36ac02fb1033a0cc56df968b4c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evsignal_new</b>(b,  x,  cb,  arg)&#160;&#160;&#160;	<a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new</a>((b), (x), <a class="el" href="event2_2event_8h.html#a59b7e95284ac1a197969d42ee9441ece">EV_SIGNAL</a>|<a class="el" href="event2_2event_8h.html#a3c4947a60eb6d09327c61f89135f9f37">EV_PERSIST</a>, (cb), (arg))</td></tr>
<tr class="separator:a990ce36ac02fb1033a0cc56df968b4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cca0259e62d40d8470e9b574568f74"><td class="memItemLeft" align="right" valign="top"><a id="af2cca0259e62d40d8470e9b574568f74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evsignal_del</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del</a>(ev)</td></tr>
<tr class="separator:af2cca0259e62d40d8470e9b574568f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9bcb501fce2f2b7d5bc19e5d53b611"><td class="memItemLeft" align="right" valign="top"><a id="aee9bcb501fce2f2b7d5bc19e5d53b611"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evsignal_pending</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a9b1687396305898af018c74e63486eb5">event_pending</a>((ev), <a class="el" href="event2_2event_8h.html#a59b7e95284ac1a197969d42ee9441ece">EV_SIGNAL</a>, (tv))</td></tr>
<tr class="separator:aee9bcb501fce2f2b7d5bc19e5d53b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39848850017245c2e946c49c5a51a9d"><td class="memItemLeft" align="right" valign="top"><a id="aa39848850017245c2e946c49c5a51a9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evsignal_initialized</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a85b94b111b8aa7fb480fc2f9da7f8e18">event_initialized</a>(ev)</td></tr>
<tr class="separator:aa39848850017245c2e946c49c5a51a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">evuser_* macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Aliases for working with user-triggered events If you need EV_PERSIST event use event_*() functions. </p>
</div></td></tr>
<tr class="memitem:ab8dcf9caae6e1f9d3dc2ddea45f1bfe8"><td class="memItemLeft" align="right" valign="top"><a id="ab8dcf9caae6e1f9d3dc2ddea45f1bfe8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evuser_new</b>(b,  cb,  arg)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new</a>((b), -1, 0, (cb), (arg))</td></tr>
<tr class="separator:ab8dcf9caae6e1f9d3dc2ddea45f1bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b0d7af364067366eb8c9d193b752cd"><td class="memItemLeft" align="right" valign="top"><a id="a39b0d7af364067366eb8c9d193b752cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evuser_del</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del</a>(ev)</td></tr>
<tr class="separator:a39b0d7af364067366eb8c9d193b752cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c99455628ca64bb0b87f5af8bdf952e"><td class="memItemLeft" align="right" valign="top"><a id="a3c99455628ca64bb0b87f5af8bdf952e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evuser_pending</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a9b1687396305898af018c74e63486eb5">event_pending</a>((ev), 0, (tv))</td></tr>
<tr class="separator:a3c99455628ca64bb0b87f5af8bdf952e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5298763263275887cfa6cb9f2bd2c9ba"><td class="memItemLeft" align="right" valign="top"><a id="a5298763263275887cfa6cb9f2bd2c9ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evuser_initialized</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a85b94b111b8aa7fb480fc2f9da7f8e18">event_initialized</a>(ev)</td></tr>
<tr class="separator:a5298763263275887cfa6cb9f2bd2c9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccbe94b015a8292dbee6edde291ccc8"><td class="memItemLeft" align="right" valign="top"><a id="a7ccbe94b015a8292dbee6edde291ccc8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evuser_trigger</b>(ev)&#160;&#160;&#160;<a class="el" href="event2_2event_8h.html#a31d9440cf2b7010e32a05a2142a91525">event_active</a>((ev), 0, 0)</td></tr>
<tr class="separator:a7ccbe94b015a8292dbee6edde291ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a185f44c610d7ee21ecba720561b2e09c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a185f44c610d7ee21ecba720561b2e09c">event_log_cb</a>) (int severity, const char *msg)</td></tr>
<tr class="separator:a185f44c610d7ee21ecba720561b2e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb799b636f0d3aab6ca17426d88473cf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#abb799b636f0d3aab6ca17426d88473cf">event_fatal_cb</a>) (int err)</td></tr>
<tr class="separator:abb799b636f0d3aab6ca17426d88473cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2307f3d9b38e07cc10c2607322d758"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>) (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>, short, void *)</td></tr>
<tr class="separator:aed2307f3d9b38e07cc10c2607322d758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f62afb6e295ee487ad947e4eec18332"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a6f62afb6e295ee487ad947e4eec18332">event_finalize_callback_fn</a>) (struct <a class="el" href="structevent.html">event</a> *, void *)</td></tr>
<tr class="separator:a6f62afb6e295ee487ad947e4eec18332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f656b17425f17ed857b96d45fc6268"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a61f656b17425f17ed857b96d45fc6268">event_base_foreach_event_cb</a>) (const struct <a class="el" href="structevent__base.html">event_base</a> *, const struct <a class="el" href="structevent.html">event</a> *, void *)</td></tr>
<tr class="separator:a61f656b17425f17ed857b96d45fc6268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae7da61aef13e27a3047151b696b44c80"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a> { <a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80ab407cae60af925dba44bd66e56e5f897">EV_FEATURE_ET</a> = 0x01
, <a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80a7a6f2de86c09b92aa175f950190bf706">EV_FEATURE_O1</a> = 0x02
, <a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80a2e964e8a8f3033d26d52831fb8eec199">EV_FEATURE_FDS</a> = 0x04
, <a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80af28b206cf4665dacc2c6bf09446e29b7">EV_FEATURE_EARLY_CLOSE</a> = 0x08
 }</td></tr>
<tr class="separator:ae7da61aef13e27a3047151b696b44c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfef69af45abee54725f40f7f29986c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5">event_base_config_flag</a> { <br />
&#160;&#160;<a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5ac1302f72251168137258335e945e2ae5">EVENT_BASE_FLAG_NOLOCK</a> = 0x01
, <a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5a230574947412d83f2dd19fe8c7d286e7">EVENT_BASE_FLAG_IGNORE_ENV</a> = 0x02
, <a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5a4ffb2510ab533d7156f412ee4f0c08ea">EVENT_BASE_FLAG_STARTUP_IOCP</a> = 0x04
, <a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5a057dff1977c48174f0a0f0c43ef92ec5">EVENT_BASE_FLAG_NO_CACHE_TIME</a> = 0x08
, <br />
&#160;&#160;<a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5acceb45f3098787247044929f92f4296e">EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST</a> = 0x10
, <a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5af6080f1d7c5067868cbc749d1cfe56e9">EVENT_BASE_FLAG_PRECISE_TIMER</a> = 0x20
<br />
 }</td></tr>
<tr class="separator:acfef69af45abee54725f40f7f29986c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a37441a3defac55b5d2513521964b2af5"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a37441a3defac55b5d2513521964b2af5">event_enable_debug_mode</a> (void)</td></tr>
<tr class="separator:a37441a3defac55b5d2513521964b2af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347923dccea548c036ccc7614c5b595"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a1347923dccea548c036ccc7614c5b595">event_debug_unassign</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr class="separator:a1347923dccea548c036ccc7614c5b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34c025430d445427a2a5661082405c3"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new</a> (void)</td></tr>
<tr class="separator:af34c025430d445427a2a5661082405c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f05aabb4fbcd2ba676bb6ba92f21630"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a7f05aabb4fbcd2ba676bb6ba92f21630">event_reinit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr class="separator:a7f05aabb4fbcd2ba676bb6ba92f21630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0096ff22ff56eae9cbbda8907183d1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a3b0096ff22ff56eae9cbbda8907183d1">event_base_dispatch</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a3b0096ff22ff56eae9cbbda8907183d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa241b1117955791e5eeb03d989e011fa"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aa241b1117955791e5eeb03d989e011fa">event_base_get_method</a> (const struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:aa241b1117955791e5eeb03d989e011fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a16b79c59dc36146ffd714819efe151"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a5a16b79c59dc36146ffd714819efe151">event_get_supported_methods</a> (void)</td></tr>
<tr class="separator:a5a16b79c59dc36146ffd714819efe151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c624a8830f69b32ee11faabc8ebb99a"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a0c624a8830f69b32ee11faabc8ebb99a">event_gettime_monotonic</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct timeval *tp)</td></tr>
<tr class="separator:a0c624a8830f69b32ee11faabc8ebb99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbf68a9eaf33ff684c01e26e25c0d7d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#afcbf68a9eaf33ff684c01e26e25c0d7d">event_base_get_num_events</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, unsigned int)</td></tr>
<tr class="separator:afcbf68a9eaf33ff684c01e26e25c0d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77d874c16d8a4ec922f64fa28a50ff1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ad77d874c16d8a4ec922f64fa28a50ff1">event_base_get_max_events</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, unsigned int, int)</td></tr>
<tr class="separator:ad77d874c16d8a4ec922f64fa28a50ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f3b4191e43c8b4758b99da761c858e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a76f3b4191e43c8b4758b99da761c858e">event_config_new</a> (void)</td></tr>
<tr class="separator:a76f3b4191e43c8b4758b99da761c858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7917192d1f78884de03a8777013fd1c"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ad7917192d1f78884de03a8777013fd1c">event_config_free</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg)</td></tr>
<tr class="separator:ad7917192d1f78884de03a8777013fd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5328011d251a7af085fdc19deb748bc"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ac5328011d251a7af085fdc19deb748bc">event_config_avoid_method</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, const char *method)</td></tr>
<tr class="separator:ac5328011d251a7af085fdc19deb748bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced890aa77dac1669325f74a27584f03"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aced890aa77dac1669325f74a27584f03">event_base_get_features</a> (const struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr class="separator:aced890aa77dac1669325f74a27584f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76526f5bcd7b05d63f38fca439d7492"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ab76526f5bcd7b05d63f38fca439d7492">event_config_require_features</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, int feature)</td></tr>
<tr class="separator:ab76526f5bcd7b05d63f38fca439d7492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e42b61a7e8465b7c897432c4ddcabd"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ae9e42b61a7e8465b7c897432c4ddcabd">event_config_set_flag</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, int flag)</td></tr>
<tr class="separator:ae9e42b61a7e8465b7c897432c4ddcabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472425045a342e48429e408eaeb81d18"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a472425045a342e48429e408eaeb81d18">event_config_set_num_cpus_hint</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, int cpus)</td></tr>
<tr class="separator:a472425045a342e48429e408eaeb81d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08f9ff880ff8a07eb623124f48f979"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aeb08f9ff880ff8a07eb623124f48f979">event_config_set_max_dispatch_interval</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, const struct timeval *max_interval, int max_callbacks, int min_priority)</td></tr>
<tr class="separator:aeb08f9ff880ff8a07eb623124f48f979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925410b1d145c85849882dd220beb9d5"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config</a> (const struct <a class="el" href="structevent__config.html">event_config</a> *)</td></tr>
<tr class="separator:a925410b1d145c85849882dd220beb9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6249f5786dee4783cada15b4a8e65d5e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a6249f5786dee4783cada15b4a8e65d5e">event_base_free</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a6249f5786dee4783cada15b4a8e65d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385fb6f81ab73f9c95d77b7179f780e0"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a385fb6f81ab73f9c95d77b7179f780e0">event_base_free_nofinalize</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a385fb6f81ab73f9c95d77b7179f780e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6be5aff4af06b22da20d5ad747ff2"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a2ec6be5aff4af06b22da20d5ad747ff2">event_set_log_callback</a> (<a class="el" href="event2_2event_8h.html#a185f44c610d7ee21ecba720561b2e09c">event_log_cb</a> cb)</td></tr>
<tr class="separator:a2ec6be5aff4af06b22da20d5ad747ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0efefe738406049a7bd71e2e59ccfb"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a1d0efefe738406049a7bd71e2e59ccfb">event_set_fatal_callback</a> (<a class="el" href="event2_2event_8h.html#abb799b636f0d3aab6ca17426d88473cf">event_fatal_cb</a> cb)</td></tr>
<tr class="separator:a1d0efefe738406049a7bd71e2e59ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce01eafdfef974a80fdf9a507f5eca9"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#abce01eafdfef974a80fdf9a507f5eca9">event_enable_debug_logging</a> (ev_uint32_t which)</td></tr>
<tr class="separator:abce01eafdfef974a80fdf9a507f5eca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100e58a411fbc2db2b316ad59169e21"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ab100e58a411fbc2db2b316ad59169e21">event_base_set</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr class="separator:ab100e58a411fbc2db2b316ad59169e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e311cff042dab77125e309315a0617"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, int)</td></tr>
<tr class="separator:a76e311cff042dab77125e309315a0617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89f0c907906f784fc80a3107016c3dc"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, const struct timeval *)</td></tr>
<tr class="separator:ab89f0c907906f784fc80a3107016c3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324bba48a369a9661d89090be180f70a"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a324bba48a369a9661d89090be180f70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9aad07575cad431e12a9046f51f634"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a9b9aad07575cad431e12a9046f51f634">event_base_loopcontinue</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a9b9aad07575cad431e12a9046f51f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c24caf82b36051648fa07b70deac3b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a17c24caf82b36051648fa07b70deac3b">event_base_got_exit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a17c24caf82b36051648fa07b70deac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a47463940fd3c4363efb91b5a283755"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a0a47463940fd3c4363efb91b5a283755">event_base_got_break</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a0a47463940fd3c4363efb91b5a283755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0b6ecbbc95137d7a6621f46670acad"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aaf0b6ecbbc95137d7a6621f46670acad">event_self_cbarg</a> (void)</td></tr>
<tr class="separator:aaf0b6ecbbc95137d7a6621f46670acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60bb980e309993205a3880de41e3ec8"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent.html">event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>, short, <a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>, void *)</td></tr>
<tr class="separator:ad60bb980e309993205a3880de41e3ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cbaa3e99d66d788985b25c7f53237d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign</a> (struct <a class="el" href="structevent.html">event</a> *, struct <a class="el" href="structevent__base.html">event_base</a> *, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>, short, <a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>, void *)</td></tr>
<tr class="separator:a71cbaa3e99d66d788985b25c7f53237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f326019b65d319b2221b7e57d56c273"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a1f326019b65d319b2221b7e57d56c273">event_free</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr class="separator:a1f326019b65d319b2221b7e57d56c273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4f70904b45eef26c4a8605fe706a32"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a5f4f70904b45eef26c4a8605fe706a32">event_base_once</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>, short, <a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>, void *, const struct timeval *)</td></tr>
<tr class="separator:a5f4f70904b45eef26c4a8605fe706a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c85ebe9cf057be1aa17724c701b0c8"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add</a> (struct <a class="el" href="structevent.html">event</a> *ev, const struct timeval *timeout)</td></tr>
<tr class="separator:ab0c85ebe9cf057be1aa17724c701b0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3aae1a8b2c0002e5744fb54ba4fe64"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a6d3aae1a8b2c0002e5744fb54ba4fe64">event_remove_timer</a> (struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a6d3aae1a8b2c0002e5744fb54ba4fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6f0f479b2b2b5c13854b7efae7b243"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr class="separator:a8d6f0f479b2b2b5c13854b7efae7b243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ae25b313b15e6038b5dd87c740e39e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a54ae25b313b15e6038b5dd87c740e39e">event_del_noblock</a> (struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a54ae25b313b15e6038b5dd87c740e39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8236f5e7e9d845cd127e768b2747df9c"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a8236f5e7e9d845cd127e768b2747df9c">event_del_block</a> (struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a8236f5e7e9d845cd127e768b2747df9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d9440cf2b7010e32a05a2142a91525"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a31d9440cf2b7010e32a05a2142a91525">event_active</a> (struct <a class="el" href="structevent.html">event</a> *ev, int res, short ncalls)</td></tr>
<tr class="separator:a31d9440cf2b7010e32a05a2142a91525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1687396305898af018c74e63486eb5"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a9b1687396305898af018c74e63486eb5">event_pending</a> (const struct <a class="el" href="structevent.html">event</a> *ev, short events, struct timeval *tv)</td></tr>
<tr class="separator:a9b1687396305898af018c74e63486eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23276914af0b2527951cc7c47b46f00b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent.html">event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a23276914af0b2527951cc7c47b46f00b">event_base_get_running_event</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr class="separator:a23276914af0b2527951cc7c47b46f00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b94b111b8aa7fb480fc2f9da7f8e18"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a85b94b111b8aa7fb480fc2f9da7f8e18">event_initialized</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a85b94b111b8aa7fb480fc2f9da7f8e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f63589ebe3e0d4c9e20447f96d343b2"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a4f63589ebe3e0d4c9e20447f96d343b2">event_get_fd</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a4f63589ebe3e0d4c9e20447f96d343b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90af034dd2638511f483bd25effdc77"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ab90af034dd2638511f483bd25effdc77">event_get_base</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:ab90af034dd2638511f483bd25effdc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70989121937ecb71358a2d76be772d51"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a70989121937ecb71358a2d76be772d51">event_get_events</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a70989121937ecb71358a2d76be772d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e325a315660638135385dc3b608bf85"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL <a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a6e325a315660638135385dc3b608bf85">event_get_callback</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:a6e325a315660638135385dc3b608bf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868b16c4dc7450e49ba277b9ee7b467"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ad868b16c4dc7450e49ba277b9ee7b467">event_get_callback_arg</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:ad868b16c4dc7450e49ba277b9ee7b467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc9ca70c2b59b3c1b5767b7675920c3"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#abbc9ca70c2b59b3c1b5767b7675920c3">event_get_priority</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr class="separator:abbc9ca70c2b59b3c1b5767b7675920c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddcda6db7bd3fc1e0f635d60e145a03"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a6ddcda6db7bd3fc1e0f635d60e145a03">event_get_assignment</a> (const struct <a class="el" href="structevent.html">event</a> *<a class="el" href="structevent.html">event</a>, struct <a class="el" href="structevent__base.html">event_base</a> **base_out, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> *fd_out, short *events_out, <a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a> *callback_out, void **arg_out)</td></tr>
<tr class="separator:a6ddcda6db7bd3fc1e0f635d60e145a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f93db0db7e74f9ae173e1766415dd56"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a0f93db0db7e74f9ae173e1766415dd56">event_get_struct_event_size</a> (void)</td></tr>
<tr class="separator:a0f93db0db7e74f9ae173e1766415dd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e8acd0630f353cb9eaca660caaad6"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#af80e8acd0630f353cb9eaca660caaad6">event_get_version</a> (void)</td></tr>
<tr class="separator:af80e8acd0630f353cb9eaca660caaad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578ddddcc39d197630e7909b7da443e3"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL ev_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a578ddddcc39d197630e7909b7da443e3">event_get_version_number</a> (void)</td></tr>
<tr class="separator:a578ddddcc39d197630e7909b7da443e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f7240248d0fbe6f1f9d94a61685d3f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#af2f7240248d0fbe6f1f9d94a61685d3f">event_base_priority_init</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, int)</td></tr>
<tr class="separator:af2f7240248d0fbe6f1f9d94a61685d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c91bec6e27bf2e26e8ecbb286787cc5"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a3c91bec6e27bf2e26e8ecbb286787cc5">event_base_get_npriorities</a> (struct <a class="el" href="structevent__base.html">event_base</a> *eb)</td></tr>
<tr class="separator:a3c91bec6e27bf2e26e8ecbb286787cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1baecb7ae859dd19fe63c0221e18e2"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a7a1baecb7ae859dd19fe63c0221e18e2">event_priority_set</a> (struct <a class="el" href="structevent.html">event</a> *, int)</td></tr>
<tr class="separator:a7a1baecb7ae859dd19fe63c0221e18e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b388babfda66dcb897c9e4dbd233b1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL const struct timeval *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a46b388babfda66dcb897c9e4dbd233b1">event_base_init_common_timeout</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, const struct timeval *duration)</td></tr>
<tr class="separator:a46b388babfda66dcb897c9e4dbd233b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb71feea97288bc15d2fba3dccd46bf"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a9bb71feea97288bc15d2fba3dccd46bf">event_set_mem_functions</a> (void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void(*free_fn)(void *ptr))</td></tr>
<tr class="separator:a9bb71feea97288bc15d2fba3dccd46bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8db0b3456973fb63a13d804edfad823"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aa8db0b3456973fb63a13d804edfad823">event_base_dump_events</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, FILE *)</td></tr>
<tr class="separator:aa8db0b3456973fb63a13d804edfad823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092013616b4636c74e889b0b015cb75e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a092013616b4636c74e889b0b015cb75e">event_base_active_by_fd</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd, short events)</td></tr>
<tr class="separator:a092013616b4636c74e889b0b015cb75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bca4d24a15bef084bf066faca8a43d2"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a4bca4d24a15bef084bf066faca8a43d2">event_base_active_by_signal</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, int sig)</td></tr>
<tr class="separator:a4bca4d24a15bef084bf066faca8a43d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5c38711c6a72545b939cc375468f79"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a7d5c38711c6a72545b939cc375468f79">event_base_foreach_event</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, <a class="el" href="event2_2event_8h.html#a61f656b17425f17ed857b96d45fc6268">event_base_foreach_event_cb</a> fn, void *arg)</td></tr>
<tr class="separator:a7d5c38711c6a72545b939cc375468f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbd35d624f1c865329a2a388afba3fd"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#a0fbd35d624f1c865329a2a388afba3fd">event_base_gettimeofday_cached</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct timeval *tv)</td></tr>
<tr class="separator:a0fbd35d624f1c865329a2a388afba3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae920425b48421c3cb7cb5e0802e4af9d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#ae920425b48421c3cb7cb5e0802e4af9d">event_base_update_cache_time</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr class="separator:ae920425b48421c3cb7cb5e0802e4af9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed24b9ff1f5b137ea2e2cc6a2bf8d1f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event2_2event_8h.html#aaed24b9ff1f5b137ea2e2cc6a2bf8d1f">libevent_global_shutdown</a> (void)</td></tr>
<tr class="separator:aaed24b9ff1f5b137ea2e2cc6a2bf8d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finalization functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are used to safely tear down an event in a multithreaded application. If you construct your events with EV_FINALIZE to avoid deadlocks, you will need a way to remove an event in the certainty that it will definitely not be running its callback when you deallocate it and its callback argument.</p>
<p>To do this, call one of event_finalize() or event_free_finalize with 0 for its first argument, the event to tear down as its second argument, and a callback function as its third argument. The callback will be invoked as part of the event loop, with the event's priority.</p>
<p>After you call a finalizer function, <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> and <a class="el" href="event2_2event_8h.html#a31d9440cf2b7010e32a05a2142a91525">event_active()</a> will no longer work on the event, and <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a> will produce a no-op. You must not try to change the event's fields with <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> or <a class="el" href="event__compat_8h.html#af06653a20ca79b6229adf89630d20916">event_set()</a> while the finalize callback is in progress. Once the callback has been invoked, you should treat the event structure as containing uninitialized memory.</p>
<p>The event_free_finalize() function frees the event after it's finalized; event_finalize() does not.</p>
<p>A finalizer callback must not make events pending or active. It must not add events, activate events, or attempt to "resuscitate" the event being finalized in any way.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
</div></td></tr>
<tr class="memitem:a61afe502421991651981de42bd6bccc7"><td class="memItemLeft" align="right" valign="top"><a id="a61afe502421991651981de42bd6bccc7"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>event_finalize</b> (unsigned, struct <a class="el" href="structevent.html">event</a> *, <a class="el" href="event2_2event_8h.html#a6f62afb6e295ee487ad947e4eec18332">event_finalize_callback_fn</a>)</td></tr>
<tr class="separator:a61afe502421991651981de42bd6bccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e49fd7fed22932900b8827e26e10fb"><td class="memItemLeft" align="right" valign="top"><a id="a70e49fd7fed22932900b8827e26e10fb"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><b>event_free_finalize</b> (unsigned, struct <a class="el" href="structevent.html">event</a> *, <a class="el" href="event2_2event_8h.html#a6f62afb6e295ee487ad947e4eec18332">event_finalize_callback_fn</a>)</td></tr>
<tr class="separator:a70e49fd7fed22932900b8827e26e10fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core functions for waiting for and receiving events, and using event bases. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a98f643f9c9063a4cbf410f519eb61e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f643f9c9063a4cbf410f519eb61e55">&#9670;&nbsp;</a></span>EV_CLOSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_CLOSED&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects connection close events. You can use this to detect when a connection has been closed, without having to read all the pending data from a connection.</p>
<p>Not all backends support EV_CLOSED. To detect or require it, use the feature flag EV_FEATURE_EARLY_CLOSE. </p>

</div>
</div>
<a id="a01084abbcdd3a58b4068359548a3ea71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01084abbcdd3a58b4068359548a3ea71">&#9670;&nbsp;</a></span>EV_ET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_ET&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select edge-triggered behavior, if supported by the backend. </p>

</div>
</div>
<a id="ac062d75b2bf9a961d893e3a71726bdff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac062d75b2bf9a961d893e3a71726bdff">&#9670;&nbsp;</a></span>EV_FINALIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_FINALIZE&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this option is provided, then <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a> will not block in one thread while waiting for the event callback to complete in another thread.</p>
<p>To use this option safely, you may need to use event_finalize() or event_free_finalize() in order to safely tear down an event in a multithreaded application. See those functions for more information. </p>

</div>
</div>
<a id="a3c4947a60eb6d09327c61f89135f9f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4947a60eb6d09327c61f89135f9f37">&#9670;&nbsp;</a></span>EV_PERSIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_PERSIST&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Persistent event: won't get removed automatically when activated.</p>
<p>When a persistent event with a timeout becomes activated, its timeout is reset to 0. </p>

</div>
</div>
<a id="a74bbaf2d529670cc0ab793497b41700f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bbaf2d529670cc0ab793497b41700f">&#9670;&nbsp;</a></span>EV_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_READ&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a socket or FD to become readable </p>

</div>
</div>
<a id="a59b7e95284ac1a197969d42ee9441ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b7e95284ac1a197969d42ee9441ece">&#9670;&nbsp;</a></span>EV_SIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_SIGNAL&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a POSIX signal to be raised </p>

</div>
</div>
<a id="a37ef4b6056484f5580f7d72fcf46fccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ef4b6056484f5580f7d72fcf46fccf">&#9670;&nbsp;</a></span>EV_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_TIMEOUT&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a timeout has occurred. It's not necessary to pass this flag to event_for new()/event_assign() to get a timeout. </p>

</div>
</div>
<a id="a2a31813fa3b26bf2d150512cbbf893f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a31813fa3b26bf2d150512cbbf893f7">&#9670;&nbsp;</a></span>EV_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_WRITE&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a socket or FD to become writeable </p>

</div>
</div>
<a id="aa3786406bc592990f0583ac211110fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3786406bc592990f0583ac211110fa3">&#9670;&nbsp;</a></span>EVENT_BASE_COUNT_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_BASE_COUNT_ACTIVE&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count the number of active events, which have been triggered. </p>

</div>
</div>
<a id="a36205e544778da7d91ec8555b962851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36205e544778da7d91ec8555b962851a">&#9670;&nbsp;</a></span>EVENT_BASE_COUNT_ADDED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_BASE_COUNT_ADDED&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count the number of events which have been added to event base, including internal events. </p>

</div>
</div>
<a id="aac4e49b51ffe924451c9048c5061a224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4e49b51ffe924451c9048c5061a224">&#9670;&nbsp;</a></span>EVENT_BASE_COUNT_VIRTUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_BASE_COUNT_VIRTUAL&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count the number of virtual events, which is used to represent an internal condition, other than a pending event, that keeps the loop from exiting. </p>

</div>
</div>
<a id="a69cc368a9137187726ef371a06f9cc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cc368a9137187726ef371a06f9cc9f">&#9670;&nbsp;</a></span>event_get_signal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define event_get_signal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev</td><td>)</td>
          <td>&#160;&#160;&#160;((int)<a class="el" href="event2_2event_8h.html#a4f63589ebe3e0d4c9e20447f96d343b2">event_get_fd</a>(ev))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the signal number assigned to a signal event </p>

</div>
</div>
<a id="ad74f7bf73ff985bfaf61c462cbba022f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74f7bf73ff985bfaf61c462cbba022f">&#9670;&nbsp;</a></span>EVENT_MAX_PRIORITIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_MAX_PRIORITIES&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Largest number of priorities that Libevent can support. </p>

</div>
</div>
<a id="ade387a9a39bbbdf40ff20b4d977ec6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade387a9a39bbbdf40ff20b4d977ec6ae">&#9670;&nbsp;</a></span>EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This definition is present if Libevent was built with support for <a class="el" href="event2_2event_8h.html#a9bb71feea97288bc15d2fba3dccd46bf">event_set_mem_functions()</a> </p>

</div>
</div>
<a id="a6751a7d5867ff8e7807400a93ffd5b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6751a7d5867ff8e7807400a93ffd5b08">&#9670;&nbsp;</a></span>EVLOOP_NO_EXIT_ON_EMPTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_NO_EXIT_ON_EMPTY&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not exit the loop because we have no pending events. Instead, keep running until <a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a> or <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> makes us stop. </p>

</div>
</div>
<a id="a10b9c102337d0ece8607c9c01bc4f7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b9c102337d0ece8607c9c01bc4f7c8">&#9670;&nbsp;</a></span>EVLOOP_NONBLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_NONBLOCK&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not block: see which events are ready now, run the callbacks of the highest-priority ones, then exit. </p>

</div>
</div>
<a id="afab575b1e867dde13a2c7f2f967e0e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab575b1e867dde13a2c7f2f967e0e4e">&#9670;&nbsp;</a></span>EVLOOP_ONCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_ONCE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until we have an active event, then exit once all active events have had their callbacks run. </p>

</div>
</div>
<a id="aad00c7d4ddbd6b590c15861a2e767182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad00c7d4ddbd6b590c15861a2e767182">&#9670;&nbsp;</a></span>LIBEVENT_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBEVENT_VERSION&#160;&#160;&#160;EVENT__VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As event_get_version, but gives the version of Libevent's headers. </p>

</div>
</div>
<a id="a8a9c8021651a2d8d7946083281279586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9c8021651a2d8d7946083281279586">&#9670;&nbsp;</a></span>LIBEVENT_VERSION_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBEVENT_VERSION_NUMBER&#160;&#160;&#160;EVENT__NUMERIC_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As event_get_version_number, but gives the version number of Libevent's headers. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a61f656b17425f17ed857b96d45fc6268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f656b17425f17ed857b96d45fc6268">&#9670;&nbsp;</a></span>event_base_foreach_event_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* event_base_foreach_event_cb) (const struct <a class="el" href="structevent__base.html">event_base</a> *, const struct <a class="el" href="structevent.html">event</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for iterating events in an event base via event_base_foreach_event </p>

</div>
</div>
<a id="aed2307f3d9b38e07cc10c2607322d758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2307f3d9b38e07cc10c2607322d758">&#9670;&nbsp;</a></span>event_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* event_callback_fn) (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>, short, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A callback function for an event.</p>
<p>It receives three arguments:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>An fd or signal </td></tr>
    <tr><td class="paramname">events</td><td>One or more EV_* flags </td></tr>
    <tr><td class="paramname">arg</td><td>A user-supplied argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> </dd></dl>

</div>
</div>
<a id="abb799b636f0d3aab6ca17426d88473cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb799b636f0d3aab6ca17426d88473cf">&#9670;&nbsp;</a></span>event_fatal_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* event_fatal_cb) (int err)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function to be called if Libevent encounters a fatal internal error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a1d0efefe738406049a7bd71e2e59ccfb">event_set_fatal_callback</a> </dd></dl>

</div>
</div>
<a id="a6f62afb6e295ee487ad947e4eec18332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f62afb6e295ee487ad947e4eec18332">&#9670;&nbsp;</a></span>event_finalize_callback_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* event_finalize_callback_fn) (struct <a class="el" href="structevent.html">event</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback type for event_finalize and event_free_finalize(). </p>

</div>
</div>
<a id="a185f44c610d7ee21ecba720561b2e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185f44c610d7ee21ecba720561b2e09c">&#9670;&nbsp;</a></span>event_log_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* event_log_cb) (int severity, const char *msg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A callback function used to intercept Libevent's log messages.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a2ec6be5aff4af06b22da20d5ad747ff2">event_set_log_callback</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acfef69af45abee54725f40f7f29986c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfef69af45abee54725f40f7f29986c5">&#9670;&nbsp;</a></span>event_base_config_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="event2_2event_8h.html#acfef69af45abee54725f40f7f29986c5">event_base_config_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A flag passed to <a class="el" href="event2_2event_8h.html#ae9e42b61a7e8465b7c897432c4ddcabd">event_config_set_flag()</a>.</p>
<p>These flags change the behavior of an allocated <a class="el" href="structevent__base.html">event_base</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ae9e42b61a7e8465b7c897432c4ddcabd">event_config_set_flag()</a>, <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a>, <a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfef69af45abee54725f40f7f29986c5ac1302f72251168137258335e945e2ae5"></a>EVENT_BASE_FLAG_NOLOCK&#160;</td><td class="fielddoc"><p>Do not allocate a lock for the event base, even if we have locking set up.</p>
<p>Setting this option will make it unsafe and nonfunctional to call functions on the base concurrently from multiple threads. </p>
</td></tr>
<tr><td class="fieldname"><a id="acfef69af45abee54725f40f7f29986c5a230574947412d83f2dd19fe8c7d286e7"></a>EVENT_BASE_FLAG_IGNORE_ENV&#160;</td><td class="fielddoc"><p>Do not check the EVENT_* environment variables when configuring an <a class="el" href="structevent__base.html">event_base</a> <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="acfef69af45abee54725f40f7f29986c5a4ffb2510ab533d7156f412ee4f0c08ea"></a>EVENT_BASE_FLAG_STARTUP_IOCP&#160;</td><td class="fielddoc"><p>Windows only: enable the IOCP dispatcher at startup </p><pre class="fragment">If this flag is set then bufferevent_socket_new() and
evconn_listener_new() will use IOCP-backed implementations
instead of the usual select-based one on Windows.
</pre> </td></tr>
<tr><td class="fieldname"><a id="acfef69af45abee54725f40f7f29986c5a057dff1977c48174f0a0f0c43ef92ec5"></a>EVENT_BASE_FLAG_NO_CACHE_TIME&#160;</td><td class="fielddoc"><p>Instead of checking the current time every time the event loop is ready to run timeout callbacks, check after each timeout callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="acfef69af45abee54725f40f7f29986c5acceb45f3098787247044929f92f4296e"></a>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST&#160;</td><td class="fielddoc"><p>If we are using the epoll backend, this flag says that it is safe to use Libevent's internal change-list code to batch up adds and deletes in order to try to do as few syscalls as possible. Setting this flag can make your code run faster, but it may trigger a Linux bug: it is not safe to use this flag if you have any fds cloned by dup() or its variants. Doing so will produce strange and hard-to-diagnose bugs.</p>
<p>This flag can also be activated by setting the EVENT_EPOLL_USE_CHANGELIST environment variable.</p>
<p>This flag has no effect if you wind up using a backend other than epoll. </p>
</td></tr>
<tr><td class="fieldname"><a id="acfef69af45abee54725f40f7f29986c5af6080f1d7c5067868cbc749d1cfe56e9"></a>EVENT_BASE_FLAG_PRECISE_TIMER&#160;</td><td class="fielddoc"><p>Ordinarily, Libevent implements its time and timeout code using the fastest monotonic timer that we have. If this flag is set, however, we use less efficient more precise timer, assuming one is present. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae7da61aef13e27a3047151b696b44c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da61aef13e27a3047151b696b44c80">&#9670;&nbsp;</a></span>event_method_feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A flag used to describe which features an <a class="el" href="structevent__base.html">event_base</a> (must) provide.</p>
<p>Because of OS limitations, not every Libevent backend supports every possible feature. You can use this type with <a class="el" href="event2_2event_8h.html#ab76526f5bcd7b05d63f38fca439d7492">event_config_require_features()</a> to tell Libevent to only proceed if your <a class="el" href="structevent__base.html">event_base</a> implements a given feature, and you can receive this type from <a class="el" href="event2_2event_8h.html#aced890aa77dac1669325f74a27584f03">event_base_get_features()</a> to see which features are available. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae7da61aef13e27a3047151b696b44c80ab407cae60af925dba44bd66e56e5f897"></a>EV_FEATURE_ET&#160;</td><td class="fielddoc"><p>Require an event method that allows edge-triggered events with EV_ET. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae7da61aef13e27a3047151b696b44c80a7a6f2de86c09b92aa175f950190bf706"></a>EV_FEATURE_O1&#160;</td><td class="fielddoc"><p>Require an event method where having one event triggered among many is [approximately] an O(1) operation. This excludes (for example) select and poll, which are approximately O(N) for N equal to the total number of possible events. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae7da61aef13e27a3047151b696b44c80a2e964e8a8f3033d26d52831fb8eec199"></a>EV_FEATURE_FDS&#160;</td><td class="fielddoc"><p>Require an event method that allows file descriptors as well as sockets. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae7da61aef13e27a3047151b696b44c80af28b206cf4665dacc2c6bf09446e29b7"></a>EV_FEATURE_EARLY_CLOSE&#160;</td><td class="fielddoc"><p>Require an event method that allows you to use EV_CLOSED to detect connection close without the necessity of reading all the pending data.</p>
<p>Methods that do support EV_CLOSED may not be able to provide support on all kernel versions. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a31d9440cf2b7010e32a05a2142a91525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d9440cf2b7010e32a05a2142a91525">&#9670;&nbsp;</a></span>event_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>ncalls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an event active.</p>
<p>You can use this function on a pending or a non-pending event to make it active, so that its callback will be run by <a class="el" href="event2_2event_8h.html#a3b0096ff22ff56eae9cbbda8907183d1">event_base_dispatch()</a> or <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a>.</p>
<p>One common use in multithreaded programs is to wake the thread running <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> from another thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event to make active. </td></tr>
    <tr><td class="paramname">res</td><td>a set of flags to pass to the event's callback. </td></tr>
    <tr><td class="paramname">ncalls</td><td>an obsolete argument: this is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0c85ebe9cf057be1aa17724c701b0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c85ebe9cf057be1aa17724c701b0c8">&#9670;&nbsp;</a></span>event_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an event to the set of pending events.</p>
<p>The function <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> schedules the execution of the event 'ev' when the condition specified by <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> or <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> occurs, or when the time specified in timeout has elapsed. If a timeout is NULL, no timeout occurs and the function will only be called if a matching event occurs. The event in the ev argument must be already initialized by <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> or <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> and may not be used in calls to <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> until it is no longer pending.</p>
<p>If the event in the ev argument already has a scheduled timeout, calling <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> replaces the old timeout with the new one if tv is non-NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct initialized via <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> or <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum amount of time to wait for the event, or NULL to wait forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>, <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a>, <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_ab0c85ebe9cf057be1aa17724c701b0c8_icgraph.png" border="0" usemap="#aevent2_2event_8h_ab0c85ebe9cf057be1aa17724c701b0c8_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_ab0c85ebe9cf057be1aa17724c701b0c8_icgraph" id="aevent2_2event_8h_ab0c85ebe9cf057be1aa17724c701b0c8_icgraph">
<area shape="rect" title=" " alt="" coords="448,78,539,105"/>
<area shape="rect" href="bufferevent_8h.html#afc5cd06cb7b574ec9746c8fb89b98491" title=" " alt="" coords="230,5,397,47"/>
<area shape="rect" href="bufferevent_8h.html#ad5381c899547a19ee6a93df63b064ad4" title=" " alt="" coords="235,71,392,112"/>
<area shape="rect" href="dns_8h.html#ad6a51e72173fcb3df380a49e8589635b" title=" " alt="" coords="227,136,400,177"/>
<area shape="rect" href="dns__compat_8h.html#a0def8fe56b2dee569e32ed685f4c22d8" title=" " alt="" coords="5,143,179,170"/>
</map>
</div>

</div>
</div>
<a id="a71cbaa3e99d66d788985b25c7f53237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cbaa3e99d66d788985b25c7f53237d">&#9670;&nbsp;</a></span>event_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_assign </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a new, already-allocated event structure to be added.</p>
<p>The function <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> prepares the event structure ev to be used in future calls to <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> and <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>. Unlike <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>, it doesn't allocate memory itself: it requires that you have already allocated a struct event, probably on the heap. Doing this will typically make your code depend on the size of the event structure, and thereby create incompatibility with future versions of Libevent.</p>
<p>The easiest way to avoid this problem is just to use <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> and <a class="el" href="event2_2event_8h.html#a1f326019b65d319b2221b7e57d56c273">event_free()</a> instead.</p>
<p>A slightly harder way to future-proof your code is to use <a class="el" href="event2_2event_8h.html#a0f93db0db7e74f9ae173e1766415dd56">event_get_struct_event_size()</a> to determine the required size of an event at runtime.</p>
<p>Note that it is NOT safe to call this function on an event that is active or pending. Doing so WILL corrupt internal data structures in Libevent, and lead to strange, hard-to-diagnose bugs. You <em>can</em> use event_assign to change an existing event, but only if it is not active or pending!</p>
<p>The arguments for this function, and the behavior of the events that it makes, are as for <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct to be modified </td></tr>
    <tr><td class="paramname">base</td><td>the event base to which ev should be attached. </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to be monitored </td></tr>
    <tr><td class="paramname">events</td><td>desired events to monitor; can be EV_READ and/or EV_WRITE </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked when the event occurs </td></tr>
    <tr><td class="paramname">callback_arg</td><td>an argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, or -1 on invalid arguments.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>, <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a>, <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>, <a class="el" href="event2_2event_8h.html#a5f4f70904b45eef26c4a8605fe706a32">event_base_once()</a>, <a class="el" href="event2_2event_8h.html#a0f93db0db7e74f9ae173e1766415dd56">event_get_struct_event_size()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a71cbaa3e99d66d788985b25c7f53237d_icgraph.png" border="0" usemap="#aevent2_2event_8h_a71cbaa3e99d66d788985b25c7f53237d_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a71cbaa3e99d66d788985b25c7f53237d_icgraph" id="aevent2_2event_8h_a71cbaa3e99d66d788985b25c7f53237d_icgraph">
<area shape="rect" title=" " alt="" coords="455,238,563,265"/>
<area shape="rect" href="bufferevent_8h.html#a44ea6c9406f855dadf4afadadbbf47d8" title=" " alt="" coords="243,5,391,47"/>
<area shape="rect" href="bufferevent_8h.html#afc5cd06cb7b574ec9746c8fb89b98491" title=" " alt="" coords="233,71,400,112"/>
<area shape="rect" href="bufferevent_8h.html#ad5381c899547a19ee6a93df63b064ad4" title=" " alt="" coords="238,136,395,177"/>
<area shape="rect" href="bufferevent_8h.html#a602cd1b787af596856f5c71d6077a041" title=" " alt="" coords="243,201,390,243"/>
<area shape="rect" href="bufferevent_8h.html#a71181be5ab504e26f866dd3d91494854" title=" " alt="" coords="227,267,407,294"/>
<area shape="rect" href="dns_8h.html#ad6a51e72173fcb3df380a49e8589635b" title=" " alt="" coords="230,319,403,360"/>
<area shape="rect" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8" title=" " alt="" coords="270,385,363,411"/>
<area shape="rect" href="event__compat_8h.html#af06653a20ca79b6229adf89630d20916" title=" " alt="" coords="273,435,360,462"/>
<area shape="rect" href="dns__compat_8h.html#a0def8fe56b2dee569e32ed685f4c22d8" title=" " alt="" coords="5,326,179,353"/>
</map>
</div>

</div>
</div>
<a id="a092013616b4636c74e889b0b015cb75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092013616b4636c74e889b0b015cb75e">&#9670;&nbsp;</a></span>event_base_active_by_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_base_active_by_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates all pending events for the given fd and event mask.</p>
<p>This function activates pending events only. Events which have not been added will not become active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the <a class="el" href="structevent__base.html">event_base</a> on which to activate the events. </td></tr>
    <tr><td class="paramname">fd</td><td>An fd to active events on. </td></tr>
    <tr><td class="paramname">events</td><td>One or more of EV_{READ,WRITE,TIMEOUT}. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a092013616b4636c74e889b0b015cb75e_cgraph.png" border="0" usemap="#aevent2_2event_8h_a092013616b4636c74e889b0b015cb75e_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_a092013616b4636c74e889b0b015cb75e_cgraph" id="aevent2_2event_8h_a092013616b4636c74e889b0b015cb75e_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,192,32"/>
<area shape="rect" href="evmap-internal_8h.html#aa7d6c5d77bf1bcbd771a9f1d87de6a25" title=" " alt="" coords="240,5,380,32"/>
</map>
</div>

</div>
</div>
<a id="a4bca4d24a15bef084bf066faca8a43d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bca4d24a15bef084bf066faca8a43d2">&#9670;&nbsp;</a></span>event_base_active_by_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_base_active_by_signal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates all pending signals with a given signal number</p>
<p>This function activates pending events only. Events which have not been added will not become active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the <a class="el" href="structevent__base.html">event_base</a> on which to activate the events. </td></tr>
    <tr><td class="paramname">fd</td><td>The signal to active events on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0096ff22ff56eae9cbbda8907183d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0096ff22ff56eae9cbbda8907183d1">&#9670;&nbsp;</a></span>event_base_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event dispatching loop</p>
<p>This loop will run the event base until either there are no more pending or active, or until something calls <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> or <a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> or <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if an error occurred, or 1 if we exited because no events were pending or active. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a3b0096ff22ff56eae9cbbda8907183d1_cgraph.png" border="0" usemap="#aevent2_2event_8h_a3b0096ff22ff56eae9cbbda8907183d1_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_a3b0096ff22ff56eae9cbbda8907183d1_cgraph" id="aevent2_2event_8h_a3b0096ff22ff56eae9cbbda8907183d1_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,164,32"/>
<area shape="rect" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617" title=" " alt="" coords="212,5,344,32"/>
</map>
</div>

</div>
</div>
<a id="aa8db0b3456973fb63a13d804edfad823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8db0b3456973fb63a13d804edfad823">&#9670;&nbsp;</a></span>event_base_dump_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_base_dump_events </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a human-readable description of all inserted and/or active events to a provided stdio stream.</p>
<p>This is intended for debugging; its format is not guaranteed to be the same between libevent versions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>An <a class="el" href="structevent__base.html">event_base</a> on which to scan the events. </td></tr>
    <tr><td class="paramname">output</td><td>A stdio file to write on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5c38711c6a72545b939cc375468f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5c38711c6a72545b939cc375468f79">&#9670;&nbsp;</a></span>event_base_foreach_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_foreach_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#a61f656b17425f17ed857b96d45fc6268">event_base_foreach_event_cb</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all added or active events events in an event loop, and invoke a given callback on each one.</p>
<p>The callback must not call any function that modifies the event base, that modifies any event in the event base, or that adds or removes any event to the event base. Doing so is unsupported and will lead to undefined behavior &ndash; likely, to crashes.</p>
<p><a class="el" href="event2_2event_8h.html#a7d5c38711c6a72545b939cc375468f79">event_base_foreach_event()</a> holds a lock on the <a class="el" href="structevent__base.html">event_base()</a> for the whole time it's running: slow callbacks are not advisable.</p>
<p>Note that Libevent adds some events of its own to make pieces of its functionality work. You must not assume that the only events you'll encounter will be the ones you added yourself.</p>
<p>The callback function must return 0 to continue iteration, or some other integer to stop iterating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>An <a class="el" href="structevent__base.html">event_base</a> on which to scan the events. </td></tr>
    <tr><td class="paramname">fn</td><td>A callback function to receive the events. </td></tr>
    <tr><td class="paramname">arg</td><td>An argument passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if we iterated over every event, or the value returned by the callback function if the loop exited early. </dd></dl>

</div>
</div>
<a id="a6249f5786dee4783cada15b4a8e65d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6249f5786dee4783cada15b4a8e65d5e">&#9670;&nbsp;</a></span>event_base_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_base_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate all memory associated with an <a class="el" href="structevent__base.html">event_base</a>, and free the base.</p>
<p>Note that this function will not close any fds or free any memory passed to event_new as the argument to callback.</p>
<p>If there are any pending finalizer callbacks, this function will invoke them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>an <a class="el" href="structevent__base.html">event_base</a> to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385fb6f81ab73f9c95d77b7179f780e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385fb6f81ab73f9c95d77b7179f780e0">&#9670;&nbsp;</a></span>event_base_free_nofinalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_base_free_nofinalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As event_base_free, but do not run finalizers. </p>

</div>
</div>
<a id="aced890aa77dac1669325f74a27584f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced890aa77dac1669325f74a27584f03">&#9670;&nbsp;</a></span>event_base_get_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_get_features </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a bitmask of the features implemented by an event base. This will be a bitwise OR of one or more of the values of event_method_feature</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a> </dd></dl>

</div>
</div>
<a id="ad77d874c16d8a4ec922f64fa28a50ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77d874c16d8a4ec922f64fa28a50ff1">&#9670;&nbsp;</a></span>event_base_get_max_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_get_max_events </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum number of events in a given <a class="el" href="structevent__base.html">event_base</a> as specified in the flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> </td></tr>
    <tr><td class="paramname">flags</td><td>a bitwise combination of the kinds of events to aggregate counts for </td></tr>
    <tr><td class="paramname">clear</td><td>option used to reset the maximum count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events specified in the flags </dd></dl>

</div>
</div>
<a id="aa241b1117955791e5eeb03d989e011fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa241b1117955791e5eeb03d989e011fa">&#9670;&nbsp;</a></span>event_base_get_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL const char* event_base_get_method </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the kernel event notification mechanism used by Libevent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string identifying the kernel event mechanism (kqueue, epoll, etc.) </dd></dl>

</div>
</div>
<a id="a3c91bec6e27bf2e26e8ecbb286787cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c91bec6e27bf2e26e8ecbb286787cc5">&#9670;&nbsp;</a></span>event_base_get_npriorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_get_npriorities </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>eb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of different event priorities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of different event priorities </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#af2f7240248d0fbe6f1f9d94a61685d3f">event_base_priority_init()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a3c91bec6e27bf2e26e8ecbb286787cc5_icgraph.png" border="0" usemap="#aevent2_2event_8h_a3c91bec6e27bf2e26e8ecbb286787cc5_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a3c91bec6e27bf2e26e8ecbb286787cc5_icgraph" id="aevent2_2event_8h_a3c91bec6e27bf2e26e8ecbb286787cc5_icgraph">
<area shape="rect" title=" " alt="" coords="239,31,437,57"/>
<area shape="rect" href="bufferevent_8h.html#a0091b3c386580cf2980039ad9a629b70" title=" " alt="" coords="9,5,187,32"/>
<area shape="rect" href="buffer_8h.html#a97293fcb83dd9d073af4cf370b9d094d" title=" " alt="" coords="5,56,191,83"/>
</map>
</div>

</div>
</div>
<a id="afcbf68a9eaf33ff684c01e26e25c0d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbf68a9eaf33ff684c01e26e25c0d7d">&#9670;&nbsp;</a></span>event_base_get_num_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_get_num_events </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of events in <a class="el" href="structevent__base.html">event_base</a>, as specified in the flags.</p>
<p>Since event base has some internal events added to make some of its functionalities work, EVENT_BASE_COUNT_ADDED may return more than the number of events you added using <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a>.</p>
<p>If you pass EVENT_BASE_COUNT_ACTIVE and EVENT_BASE_COUNT_ADDED together, an active event will be counted twice. However, this might not be the case in future libevent versions. The return value is an indication of the work load, but the user shouldn't rely on the exact value as this may change in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> </td></tr>
    <tr><td class="paramname">flags</td><td>a bitwise combination of the kinds of events to aggregate counts for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events specified in the flags </dd></dl>

</div>
</div>
<a id="a23276914af0b2527951cc7c47b46f00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23276914af0b2527951cc7c47b46f00b">&#9670;&nbsp;</a></span>event_base_get_running_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent.html">event</a>* event_base_get_running_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If called from within the callback for an event, returns that event.</p>
<p>The behavior of this function is not defined when called from outside the callback function for an event. </p>

</div>
</div>
<a id="a0fbd35d624f1c865329a2a388afba3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbd35d624f1c865329a2a388afba3fd">&#9670;&nbsp;</a></span>event_base_gettimeofday_cached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_gettimeofday_cached </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets 'tv' to the current time (as returned by gettimeofday()), looking at the cached value in 'base' if possible, and calling gettimeofday() or clock_gettime() as appropriate if there is no cached time.</p>
<p>Generally, this value will only be cached while actually processing event callbacks, and may be very inaccurate if your callbacks take a long time to execute.</p>
<p>Returns 0 on success, negative on failure. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a0fbd35d624f1c865329a2a388afba3fd_icgraph.png" border="0" usemap="#aevent2_2event_8h_a0fbd35d624f1c865329a2a388afba3fd_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a0fbd35d624f1c865329a2a388afba3fd_icgraph" id="aevent2_2event_8h_a0fbd35d624f1c865329a2a388afba3fd_icgraph">
<area shape="rect" title=" " alt="" coords="220,39,412,80"/>
<area shape="rect" href="bufferevent_8h.html#afc5cd06cb7b574ec9746c8fb89b98491" title=" " alt="" coords="5,5,172,47"/>
<area shape="rect" href="bufferevent_8h.html#ad5381c899547a19ee6a93df63b064ad4" title=" " alt="" coords="10,71,167,112"/>
</map>
</div>

</div>
</div>
<a id="a0a47463940fd3c4363efb91b5a283755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a47463940fd3c4363efb91b5a283755">&#9670;&nbsp;</a></span>event_base_got_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_got_break </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the event loop was told to abort immediately by <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a>.</p>
<p>This function will return true for an <a class="el" href="structevent__base.html">event_base</a> at every point after <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> is called, until the event loop is next entered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> was called on this event base, or 0 otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> </dd>
<dd>
<a class="el" href="event2_2event_8h.html#a17c24caf82b36051648fa07b70deac3b">event_base_got_exit()</a> </dd></dl>

</div>
</div>
<a id="a17c24caf82b36051648fa07b70deac3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c24caf82b36051648fa07b70deac3b">&#9670;&nbsp;</a></span>event_base_got_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_got_exit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the event loop was told to exit by <a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a>.</p>
<p>This function will return true for an <a class="el" href="structevent__base.html">event_base</a> at every point after <a class="el" href="event__compat_8h.html#a88b7e5bb1e7bd5e617167ed6192fdd66">event_loopexit()</a> is called, until the event loop is next entered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a> was called on this event base, or 0 otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a> </dd>
<dd>
<a class="el" href="event2_2event_8h.html#a0a47463940fd3c4363efb91b5a283755">event_base_got_break()</a> </dd></dl>

</div>
</div>
<a id="a46b388babfda66dcb897c9e4dbd233b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b388babfda66dcb897c9e4dbd233b1">&#9670;&nbsp;</a></span>event_base_init_common_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL const struct timeval* event_base_init_common_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare an <a class="el" href="structevent__base.html">event_base</a> to use a large number of timeouts with the same duration.</p>
<p>Libevent's default scheduling algorithm is optimized for having a large number of timeouts with their durations more or less randomly distributed. But if you have a large number of timeouts that all have the same duration (for example, if you have a large number of connections that all have a 10-second timeout), then you can improve Libevent's performance by telling Libevent about it.</p>
<p>To do this, call this function with the common duration. It will return a pointer to a different, opaque timeout value. (Don't depend on its actual contents!) When you use this timeout value in <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a>, Libevent will schedule the event more efficiently.</p>
<p>(This optimization probably will not be worthwhile until you have thousands or tens of thousands of events with the same timeout.) </p>

</div>
</div>
<a id="a76e311cff042dab77125e309315a0617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e311cff042dab77125e309315a0617">&#9670;&nbsp;</a></span>event_base_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_loop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for events to become active, and run their callbacks.</p>
<p>This is a more flexible version of <a class="el" href="event2_2event_8h.html#a3b0096ff22ff56eae9cbbda8907183d1">event_base_dispatch()</a>.</p>
<p>By default, this loop will run the event base until either there are no more pending or active events, or until something calls <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> or <a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a>. You can override this behavior with the 'flags' argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> or <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> </td></tr>
    <tr><td class="paramname">flags</td><td>any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if an error occurred, or 1 if we exited because no events were pending or active. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a>, <a class="el" href="event2_2event_8h.html#a3b0096ff22ff56eae9cbbda8907183d1">event_base_dispatch()</a>, <a class="el" href="event2_2event_8h.html#afab575b1e867dde13a2c7f2f967e0e4e">EVLOOP_ONCE</a>, <a class="el" href="event2_2event_8h.html#a10b9c102337d0ece8607c9c01bc4f7c8">EVLOOP_NONBLOCK</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a76e311cff042dab77125e309315a0617_icgraph.png" border="0" usemap="#aevent2_2event_8h_a76e311cff042dab77125e309315a0617_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a76e311cff042dab77125e309315a0617_icgraph" id="aevent2_2event_8h_a76e311cff042dab77125e309315a0617_icgraph">
<area shape="rect" title=" " alt="" coords="381,31,513,57"/>
<area shape="rect" href="event2_2event_8h.html#a3b0096ff22ff56eae9cbbda8907183d1" title=" " alt="" coords="175,5,333,32"/>
<area shape="rect" href="event__compat_8h.html#a3d6542d4518f6873ef9d308e3ee525e1" title=" " alt="" coords="207,56,301,83"/>
<area shape="rect" href="event__compat_8h.html#af4db42ebbe9e6ee92128e99523e5987f" title=" " alt="" coords="5,56,127,83"/>
</map>
</div>

</div>
</div>
<a id="a324bba48a369a9661d89090be180f70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324bba48a369a9661d89090be180f70a">&#9670;&nbsp;</a></span>event_base_loopbreak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_loopbreak </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort the active <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> immediately.</p>
<p><a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> will abort the loop after the next event is completed; <a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> is typically invoked from this event's callback. This behavior is analogous to the "break;" statement.</p>
<p>Subsequent invocations of <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> will proceed normally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc">event_base_loopexit()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a324bba48a369a9661d89090be180f70a_icgraph.png" border="0" usemap="#aevent2_2event_8h_a324bba48a369a9661d89090be180f70a_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a324bba48a369a9661d89090be180f70a_icgraph" id="aevent2_2event_8h_a324bba48a369a9661d89090be180f70a_icgraph">
<area shape="rect" title=" " alt="" coords="184,5,353,32"/>
<area shape="rect" href="event__compat_8h.html#a497e5e360112dcbdc8409ecb45c2c565" title=" " alt="" coords="5,5,136,32"/>
</map>
</div>

</div>
</div>
<a id="a9b9aad07575cad431e12a9046f51f634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9aad07575cad431e12a9046f51f634">&#9670;&nbsp;</a></span>event_base_loopcontinue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_loopcontinue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell the active <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> to scan for new events immediately.</p>
<p>Calling this function makes the currently active <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> start the loop over again (scanning for new events) after the current event callback finishes. If the event loop is not running, this function has no effect.</p>
<p><a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> is typically invoked from this event's callback. This behavior is analogous to the "continue;" statement.</p>
<p>Subsequent invocations of event loop will proceed normally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> </dd></dl>

</div>
</div>
<a id="ab89f0c907906f784fc80a3107016c3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89f0c907906f784fc80a3107016c3dc">&#9670;&nbsp;</a></span>event_base_loopexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_loopexit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>event_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the event loop after the specified time</p>
<p>The next <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> iteration after the given timer expires will complete normally (handling all queued events) then exit without blocking for events again.</p>
<p>Subsequent invocations of <a class="el" href="event2_2event_8h.html#a76e311cff042dab77125e309315a0617">event_base_loop()</a> will proceed normally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6">event_init()</a> </td></tr>
    <tr><td class="paramname">tv</td><td>the amount of time after which the loop should terminate, or NULL to exit after running all currently active events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a324bba48a369a9661d89090be180f70a">event_base_loopbreak()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_ab89f0c907906f784fc80a3107016c3dc_cgraph.png" border="0" usemap="#aevent2_2event_8h_ab89f0c907906f784fc80a3107016c3dc_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_ab89f0c907906f784fc80a3107016c3dc_cgraph" id="aevent2_2event_8h_ab89f0c907906f784fc80a3107016c3dc_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,163,32"/>
<area shape="rect" href="event2_2event_8h.html#a5f4f70904b45eef26c4a8605fe706a32" title=" " alt="" coords="211,5,345,32"/>
</map>
</div>

</div>
</div>
<a id="af34c025430d445427a2a5661082405c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c025430d445427a2a5661082405c3">&#9670;&nbsp;</a></span>event_base_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a>* event_base_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and return a new <a class="el" href="structevent__base.html">event_base</a> to use with the rest of Libevent.</p>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structevent__base.html">event_base</a> on success, or NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a6249f5786dee4783cada15b4a8e65d5e">event_base_free()</a>, <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_af34c025430d445427a2a5661082405c3_cgraph.png" border="0" usemap="#aevent2_2event_8h_af34c025430d445427a2a5661082405c3_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_af34c025430d445427a2a5661082405c3_cgraph" id="aevent2_2event_8h_af34c025430d445427a2a5661082405c3_cgraph">
<area shape="rect" title=" " alt="" coords="5,71,136,98"/>
<area shape="rect" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5" title=" " alt="" coords="184,5,351,47"/>
<area shape="rect" href="event2_2event_8h.html#ad7917192d1f78884de03a8777013fd1c" title=" " alt="" coords="198,71,337,98"/>
<area shape="rect" href="event2_2event_8h.html#a76f3b4191e43c8b4758b99da761c858e" title=" " alt="" coords="198,122,337,149"/>
</map>
</div>

</div>
</div>
<a id="a925410b1d145c85849882dd220beb9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925410b1d145c85849882dd220beb9d5">&#9670;&nbsp;</a></span>event_base_new_with_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a>* event_base_new_with_config </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the event API.</p>
<p>Use <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> to initialize a new event base, taking the specified configuration under consideration. The configuration object can currently be used to avoid certain event notification mechanisms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>the event configuration object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an initialized <a class="el" href="structevent__base.html">event_base</a> that can be used to registering events, or NULL if no event base can be created with the requested <a class="el" href="structevent__config.html">event_config</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a>, <a class="el" href="event2_2event_8h.html#a6249f5786dee4783cada15b4a8e65d5e">event_base_free()</a>, <a class="el" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6">event_init()</a>, <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a925410b1d145c85849882dd220beb9d5_icgraph.png" border="0" usemap="#aevent2_2event_8h_a925410b1d145c85849882dd220beb9d5_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a925410b1d145c85849882dd220beb9d5_icgraph" id="aevent2_2event_8h_a925410b1d145c85849882dd220beb9d5_icgraph">
<area shape="rect" title=" " alt="" coords="184,23,351,65"/>
<area shape="rect" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3" title=" " alt="" coords="5,5,136,32"/>
<area shape="rect" href="event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" title=" " alt="" coords="27,56,114,83"/>
</map>
</div>

</div>
</div>
<a id="a5f4f70904b45eef26c4a8605fe706a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4f70904b45eef26c4a8605fe706a32">&#9670;&nbsp;</a></span>event_base_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_once </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a one-time event</p>
<p>The function <a class="el" href="event2_2event_8h.html#a5f4f70904b45eef26c4a8605fe706a32">event_base_once()</a> is similar to <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>. However, it schedules a callback to be called exactly once, and does not require the caller to prepare an event structure.</p>
<p>Note that in Libevent 2.0 and earlier, if the event is never triggered, the internal memory used to hold it will never be freed. In Libevent 2.1, the internal memory will get freed by <a class="el" href="event2_2event_8h.html#a6249f5786dee4783cada15b4a8e65d5e">event_base_free()</a> if the event is never triggered. The 'arg' value, however, will not get freed in either case&ndash;you'll need to free that on your own if you want it to go away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>an <a class="el" href="structevent__base.html">event_base</a> </td></tr>
    <tr><td class="paramname">fd</td><td>a file descriptor to monitor, or -1 for no fd. </td></tr>
    <tr><td class="paramname">events</td><td><a class="el" href="structevent.html">event(s)</a> to monitor; can be any of EV_READ | EV_WRITE, or EV_TIMEOUT </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked when the event occurs </td></tr>
    <tr><td class="paramname">arg</td><td>an argument to be passed to the callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum amount of time to wait for the event. NULL makes an EV_READ/EV_WRITE event make forever; NULL makes an EV_TIMEOUT event success immediately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a5f4f70904b45eef26c4a8605fe706a32_icgraph.png" border="0" usemap="#aevent2_2event_8h_a5f4f70904b45eef26c4a8605fe706a32_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a5f4f70904b45eef26c4a8605fe706a32_icgraph" id="aevent2_2event_8h_a5f4f70904b45eef26c4a8605fe706a32_icgraph">
<area shape="rect" title=" " alt="" coords="377,31,512,57"/>
<area shape="rect" href="event2_2event_8h.html#ab89f0c907906f784fc80a3107016c3dc" title=" " alt="" coords="172,5,329,32"/>
<area shape="rect" href="event__compat_8h.html#aa7139d18495e80b2e31961c1c553d45e" title=" " alt="" coords="202,56,299,83"/>
<area shape="rect" href="event__compat_8h.html#a88b7e5bb1e7bd5e617167ed6192fdd66" title=" " alt="" coords="5,56,124,83"/>
</map>
</div>

</div>
</div>
<a id="af2f7240248d0fbe6f1f9d94a61685d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f7240248d0fbe6f1f9d94a61685d3f">&#9670;&nbsp;</a></span>event_base_priority_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_priority_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npriorities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of different event priorities</p>
<p>By default Libevent schedules all active events with the same priority. However, some time it is desirable to process some events with a higher priority than others. For that reason, Libevent supports strict priority queues. Active events with a lower priority are always processed before events with a higher priority.</p>
<p>The number of different priorities can be set initially with the <a class="el" href="event2_2event_8h.html#af2f7240248d0fbe6f1f9d94a61685d3f">event_base_priority_init()</a> function. This function should be called before the first call to <a class="el" href="event2_2event_8h.html#a3b0096ff22ff56eae9cbbda8907183d1">event_base_dispatch()</a>. The <a class="el" href="event2_2event_8h.html#a7a1baecb7ae859dd19fe63c0221e18e2">event_priority_set()</a> function can be used to assign a priority to an event. By default, Libevent assigns the middle priority to all events unless their priority is explicitly set.</p>
<p>Note that urgent-priority events can starve less-urgent events: after running all urgent-priority callbacks, Libevent checks for more urgent events again, before running less-urgent events. Less-urgent events will not have their callbacks run until there are no events more urgent than them that want to be active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> </td></tr>
    <tr><td class="paramname">npriorities</td><td>the maximum number of priorities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a7a1baecb7ae859dd19fe63c0221e18e2">event_priority_set()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_af2f7240248d0fbe6f1f9d94a61685d3f_icgraph.png" border="0" usemap="#aevent2_2event_8h_af2f7240248d0fbe6f1f9d94a61685d3f_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_af2f7240248d0fbe6f1f9d94a61685d3f_icgraph" id="aevent2_2event_8h_af2f7240248d0fbe6f1f9d94a61685d3f_icgraph">
<area shape="rect" title=" " alt="" coords="195,5,373,32"/>
<area shape="rect" href="event__compat_8h.html#ade115d1b3302c33a6308c50964b6304e" title=" " alt="" coords="5,5,147,32"/>
</map>
</div>

</div>
</div>
<a id="ab100e58a411fbc2db2b316ad59169e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab100e58a411fbc2db2b316ad59169e21">&#9670;&nbsp;</a></span>event_base_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associate a different event base with an event.</p>
<p>The event to be associated must not be currently active or pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the event base </td></tr>
    <tr><td class="paramname">ev</td><td>the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_ab100e58a411fbc2db2b316ad59169e21_icgraph.png" border="0" usemap="#aevent2_2event_8h_ab100e58a411fbc2db2b316ad59169e21_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_ab100e58a411fbc2db2b316ad59169e21_icgraph" id="aevent2_2event_8h_ab100e58a411fbc2db2b316ad59169e21_icgraph">
<area shape="rect" title=" " alt="" coords="721,5,845,32"/>
<area shape="rect" href="bufferevent_8h.html#acb59fdb64642f73a96c84adeb97311cb" title=" " alt="" coords="511,5,673,32"/>
<area shape="rect" href="http__compat_8h.html#a005fff08e18b6ca6689c1226dd9d00fb" title=" " alt="" coords="256,5,463,32"/>
<area shape="rect" href="rpc_8h.html#a9e3bedffaef59f2ccc1c0003ce05da8c" title=" " alt="" coords="5,5,208,32"/>
</map>
</div>

</div>
</div>
<a id="ae920425b48421c3cb7cb5e0802e4af9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae920425b48421c3cb7cb5e0802e4af9d">&#9670;&nbsp;</a></span>event_base_update_cache_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_base_update_cache_time </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update cached_tv in the 'base' to the current time</p>
<p>You can use this function is useful for selectively increasing the accuracy of the cached time value in 'base' during callbacks that take a long time to execute.</p>
<p>This function has no effect if the base is currently not in its event loop, or if timeval caching is disabled via EVENT_BASE_FLAG_NO_CACHE_TIME.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="ac5328011d251a7af085fdc19deb748bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5328011d251a7af085fdc19deb748bc">&#9670;&nbsp;</a></span>event_config_avoid_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_config_avoid_method </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters an event method that should be avoided into the configuration.</p>
<p>This can be used to avoid event mechanisms that do not support certain file descriptor types, or for debugging to avoid certain event mechanisms. An application can make use of multiple event bases to accommodate incompatible file descriptor types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>the event configuration object </td></tr>
    <tr><td class="paramname">method</td><td>the name of the event method to avoid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ad7917192d1f78884de03a8777013fd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7917192d1f78884de03a8777013fd1c">&#9670;&nbsp;</a></span>event_config_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_config_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates all memory associated with an event configuration object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>the event configuration object to be freed. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_ad7917192d1f78884de03a8777013fd1c_icgraph.png" border="0" usemap="#aevent2_2event_8h_ad7917192d1f78884de03a8777013fd1c_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_ad7917192d1f78884de03a8777013fd1c_icgraph" id="aevent2_2event_8h_ad7917192d1f78884de03a8777013fd1c_icgraph">
<area shape="rect" title=" " alt="" coords="184,5,323,32"/>
<area shape="rect" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3" title=" " alt="" coords="5,5,136,32"/>
</map>
</div>

</div>
</div>
<a id="a76f3b4191e43c8b4758b99da761c858e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f3b4191e43c8b4758b99da761c858e">&#9670;&nbsp;</a></span>event_config_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__config.html">event_config</a>* event_config_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new event configuration object.</p>
<p>The event configuration object can be used to change the behavior of an event base.</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="structevent__config.html">event_config</a> object that can be used to store configuration, or NULL if an error is encountered. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a>, <a class="el" href="event2_2event_8h.html#ad7917192d1f78884de03a8777013fd1c">event_config_free()</a>, <a class="el" href="structevent__config.html">event_config</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a76f3b4191e43c8b4758b99da761c858e_icgraph.png" border="0" usemap="#aevent2_2event_8h_a76f3b4191e43c8b4758b99da761c858e_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a76f3b4191e43c8b4758b99da761c858e_icgraph" id="aevent2_2event_8h_a76f3b4191e43c8b4758b99da761c858e_icgraph">
<area shape="rect" title=" " alt="" coords="184,5,323,32"/>
<area shape="rect" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3" title=" " alt="" coords="5,5,136,32"/>
</map>
</div>

</div>
</div>
<a id="ab76526f5bcd7b05d63f38fca439d7492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76526f5bcd7b05d63f38fca439d7492">&#9670;&nbsp;</a></span>event_config_require_features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_config_require_features </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters a required event method feature that the application demands.</p>
<p>Note that not every feature or combination of features is supported on every platform. Code that requests features should be prepared to handle the case where <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> returns NULL, as in: </p><pre>
  event_config_require_features(cfg, EV_FEATURE_ET);
  base = event_base_new_with_config(cfg);
  if (base == NULL) {
    // We can't get edge-triggered behavior here.
    event_config_require_features(cfg, 0);
    base = event_base_new_with_config(cfg);
  }
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>the event configuration object </td></tr>
    <tr><td class="paramname">feature</td><td>a bitfield of one or more event_method_feature values. Replaces values from previous calls to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a>, <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> </dd></dl>

</div>
</div>
<a id="ae9e42b61a7e8465b7c897432c4ddcabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e42b61a7e8465b7c897432c4ddcabd">&#9670;&nbsp;</a></span>event_config_set_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_config_set_flag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets one or more flags to configure what parts of the eventual <a class="el" href="structevent__base.html">event_base</a> will be initialized, and how they'll work.</p>
<dl class="section see"><dt>See also</dt><dd>event_base_config_flags, <a class="el" href="event2_2event_8h.html#a925410b1d145c85849882dd220beb9d5">event_base_new_with_config()</a> </dd></dl>

</div>
</div>
<a id="aeb08f9ff880ff8a07eb623124f48f979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb08f9ff880ff8a07eb623124f48f979">&#9670;&nbsp;</a></span>event_config_set_max_dispatch_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_config_set_max_dispatch_interval </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>max_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record an interval and/or a number of callbacks after which the event base should check for new events. By default, the event base will run as many events are as activated at the highest activated priority before checking for new events. If you configure it by setting max_interval, it will check the time after each callback, and not allow more than max_interval to elapse before checking for new events. If you configure it by setting max_callbacks to a value &gt;= 0, it will run no more than max_callbacks callbacks before checking for new events.</p>
<p>This option can decrease the latency of high-priority events, and avoid priority inversions where multiple low-priority events keep us from polling for high-priority events, but at the expense of slightly decreasing the throughput. Use it with caution!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>The <a class="el" href="structevent__base.html">event_base</a> configuration object. </td></tr>
    <tr><td class="paramname">max_interval</td><td>An interval after which Libevent should stop running callbacks and check for more events, or NULL if there should be no such interval. </td></tr>
    <tr><td class="paramname">max_callbacks</td><td>A number of callbacks after which Libevent should stop running callbacks and check for more events, or -1 if there should be no such limit. </td></tr>
    <tr><td class="paramname">min_priority</td><td>A priority below which max_interval and max_callbacks should not be enforced. If this is set to 0, they are enforced for events of every priority; if it's set to 1, they're enforced for events of priority 1 and above, and so on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a472425045a342e48429e408eaeb81d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472425045a342e48429e408eaeb81d18">&#9670;&nbsp;</a></span>event_config_set_num_cpus_hint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_config_set_num_cpus_hint </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a hint for the number of CPUs in the system. This is used for tuning thread pools, etc, for optimal performance. In Libevent 2.0, it is only on Windows, and only when IOCP is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>the event configuration object </td></tr>
    <tr><td class="paramname">cpus</td><td>the number of cpus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a1347923dccea548c036ccc7614c5b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1347923dccea548c036ccc7614c5b595">&#9670;&nbsp;</a></span>event_debug_unassign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_debug_unassign </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When debugging mode is enabled, informs Libevent that an event should no longer be considered as assigned. When debugging mode is not enabled, does nothing.</p>
<p>This function must only be called on a non-added event.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a37441a3defac55b5d2513521964b2af5">event_enable_debug_mode()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a1347923dccea548c036ccc7614c5b595_icgraph.png" border="0" usemap="#aevent2_2event_8h_a1347923dccea548c036ccc7614c5b595_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a1347923dccea548c036ccc7614c5b595_icgraph" id="aevent2_2event_8h_a1347923dccea548c036ccc7614c5b595_icgraph">
<area shape="rect" title=" " alt="" coords="617,31,788,57"/>
<area shape="rect" href="event2_2event_8h.html#a7f05aabb4fbcd2ba676bb6ba92f21630" title=" " alt="" coords="432,5,532,32"/>
<area shape="rect" href="http_8h.html#aaf15e06932005ac0bc890b6fe72b19e3" title=" " alt="" coords="395,56,569,83"/>
<area shape="rect" href="http_8h.html#a12b2e61a0088e3707198876ae1e61f3f" title=" " alt="" coords="228,5,325,32"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="207,56,347,83"/>
<area shape="rect" href="rpc_8h.html#ab8579f465aee520bb8ac1b208d1d8d95" title=" " alt="" coords="213,107,340,133"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="5,56,159,83"/>
</map>
</div>

</div>
</div>
<a id="a8d6f0f479b2b2b5c13854b7efae7b243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6f0f479b2b2b5c13854b7efae7b243">&#9670;&nbsp;</a></span>event_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_del </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an event from the set of monitored events.</p>
<p>The function <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a> will cancel the event in the argument ev. If the event has already executed or has never been added the call will have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct to be removed from the working set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a8d6f0f479b2b2b5c13854b7efae7b243_icgraph.png" border="0" usemap="#aevent2_2event_8h_a8d6f0f479b2b2b5c13854b7efae7b243_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a8d6f0f479b2b2b5c13854b7efae7b243_icgraph" id="aevent2_2event_8h_a8d6f0f479b2b2b5c13854b7efae7b243_icgraph">
<area shape="rect" title=" " alt="" coords="725,143,812,170"/>
<area shape="rect" href="bufferevent_8h.html#a5f4f37207371ed122bd5866a55769be1" title=" " alt="" coords="479,5,645,47"/>
<area shape="rect" href="bufferevent_8h.html#ad5381c899547a19ee6a93df63b064ad4" title=" " alt="" coords="483,71,641,112"/>
<area shape="rect" href="dns_8h.html#af942ce8b6a65052f4b6def91a3390a61" title=" " alt="" coords="447,136,677,177"/>
<area shape="rect" href="event2_2event_8h.html#a1f326019b65d319b2221b7e57d56c273" title=" " alt="" coords="516,202,608,229"/>
<area shape="rect" href="http_8h.html#aaf15e06932005ac0bc890b6fe72b19e3" title=" " alt="" coords="475,253,649,279"/>
<area shape="rect" href="dns__compat_8h.html#a6c7b5be4d918882465ef75f4a1478124" title=" " alt="" coords="207,136,399,177"/>
<area shape="rect" href="http_8h.html#a12b2e61a0088e3707198876ae1e61f3f" title=" " alt="" coords="254,202,351,229"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="233,253,373,279"/>
<area shape="rect" href="rpc_8h.html#ab8579f465aee520bb8ac1b208d1d8d95" title=" " alt="" coords="239,303,366,330"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="5,253,159,279"/>
</map>
</div>

</div>
</div>
<a id="a8236f5e7e9d845cd127e768b2747df9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8236f5e7e9d845cd127e768b2747df9c">&#9670;&nbsp;</a></span>event_del_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_del_block </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>, but always blocks while the event's callback is running in another thread, even if the event was constructed with the EV_FINALIZE flag. </p>

</div>
</div>
<a id="a54ae25b313b15e6038b5dd87c740e39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ae25b313b15e6038b5dd87c740e39e">&#9670;&nbsp;</a></span>event_del_noblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_del_noblock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>, but never blocks while the event's callback is running in another thread, even if the event was constructed without the EV_FINALIZE flag. </p>

</div>
</div>
<a id="abce01eafdfef974a80fdf9a507f5eca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce01eafdfef974a80fdf9a507f5eca9">&#9670;&nbsp;</a></span>event_enable_debug_logging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_enable_debug_logging </td>
          <td>(</td>
          <td class="paramtype">ev_uint32_t&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn on debugging logs and have them sent to the default log handler.</p>
<p>This is a global setting; if you are going to call it, you must call this before any calls that create an event-base. You must call it before any multithreaded use of Libevent.</p>
<p>Debug logs are verbose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>Controls which debug messages are turned on. This option is unused for now; for forward compatibility, you must pass in the constant "EVENT_DBG_ALL" to turn debugging logs on, or "EVENT_DBG_NONE" to turn debugging logs off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37441a3defac55b5d2513521964b2af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37441a3defac55b5d2513521964b2af5">&#9670;&nbsp;</a></span>event_enable_debug_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_enable_debug_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable some relatively expensive debugging checks in Libevent that would normally be turned off. Generally, these checks cause code that would otherwise crash mysteriously to fail earlier with an assertion failure. Note that this method MUST be called before any events or event_bases have been created.</p>
<p>Debug mode can currently catch the following errors: An event is re-assigned while it is added Any function is called on a non-assigned event</p>
<p>Note that debugging mode uses memory to track every event that has been initialized (via event_assign, event_set, or event_new) but not yet released (via event_free or event_debug_unassign). If you want to use debug mode, and you find yourself running out of memory, you will need to use event_debug_unassign to explicitly stop tracking events that are no longer considered set-up.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a1347923dccea548c036ccc7614c5b595">event_debug_unassign()</a> </dd></dl>

</div>
</div>
<a id="a1f326019b65d319b2221b7e57d56c273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f326019b65d319b2221b7e57d56c273">&#9670;&nbsp;</a></span>event_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate a struct event * returned by <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>.</p>
<p>If the event is pending or active, this function makes it non-pending and non-active first. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a1f326019b65d319b2221b7e57d56c273_cgraph.png" border="0" usemap="#aevent2_2event_8h_a1f326019b65d319b2221b7e57d56c273_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_a1f326019b65d319b2221b7e57d56c273_cgraph" id="aevent2_2event_8h_a1f326019b65d319b2221b7e57d56c273_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,97,32"/>
<area shape="rect" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243" title=" " alt="" coords="145,5,232,32"/>
</map>
</div>

</div>
</div>
<a id="a6ddcda6db7bd3fc1e0f635d60e145a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddcda6db7bd3fc1e0f635d60e145a03">&#9670;&nbsp;</a></span>event_get_assignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_get_assignment </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> **&#160;</td>
          <td class="paramname"><em>base_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> *&#160;</td>
          <td class="paramname"><em>fd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>events_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a> *&#160;</td>
          <td class="paramname"><em>callback_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>arg_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract <em>all</em> of arguments given to construct a given event. The <a class="el" href="structevent__base.html">event_base</a> is copied into *base_out, the fd is copied into *fd_out, and so on.</p>
<p>If any of the "_out" arguments is NULL, it will be ignored. </p>

</div>
</div>
<a id="ab90af034dd2638511f483bd25effdc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90af034dd2638511f483bd25effdc77">&#9670;&nbsp;</a></span>event_get_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a>* event_get_base </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the <a class="el" href="structevent__base.html">event_base</a> associated with an event. </p>

</div>
</div>
<a id="a6e325a315660638135385dc3b608bf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e325a315660638135385dc3b608bf85">&#9670;&nbsp;</a></span>event_get_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL <a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a> event_get_callback </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the callback assigned to an event. </p>

</div>
</div>
<a id="ad868b16c4dc7450e49ba277b9ee7b467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868b16c4dc7450e49ba277b9ee7b467">&#9670;&nbsp;</a></span>event_get_callback_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void* event_get_callback_arg </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the callback argument assigned to an event. </p>

</div>
</div>
<a id="a70989121937ecb71358a2d76be772d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70989121937ecb71358a2d76be772d51">&#9670;&nbsp;</a></span>event_get_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL short event_get_events </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the events (EV_READ, EV_WRITE, etc) assigned to an event. </p>

</div>
</div>
<a id="a4f63589ebe3e0d4c9e20447f96d343b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f63589ebe3e0d4c9e20447f96d343b2">&#9670;&nbsp;</a></span>event_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> event_get_fd </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the socket or signal assigned to an event, or -1 if the event has no socket. </p>

</div>
</div>
<a id="abbc9ca70c2b59b3c1b5767b7675920c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc9ca70c2b59b3c1b5767b7675920c3">&#9670;&nbsp;</a></span>event_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_get_priority </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the priority of an event. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="event__compat_8h.html#ade115d1b3302c33a6308c50964b6304e">event_priority_init()</a>, <a class="el" href="event2_2event_8h.html#abbc9ca70c2b59b3c1b5767b7675920c3">event_get_priority()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_abbc9ca70c2b59b3c1b5767b7675920c3_icgraph.png" border="0" usemap="#aevent2_2event_8h_abbc9ca70c2b59b3c1b5767b7675920c3_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_abbc9ca70c2b59b3c1b5767b7675920c3_icgraph" id="aevent2_2event_8h_abbc9ca70c2b59b3c1b5767b7675920c3_icgraph">
<area shape="rect" title=" " alt="" coords="232,5,373,32"/>
<area shape="rect" href="bufferevent_8h.html#a0091b3c386580cf2980039ad9a629b70" title=" " alt="" coords="5,5,184,32"/>
</map>
</div>

</div>
</div>
<a id="a0f93db0db7e74f9ae173e1766415dd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f93db0db7e74f9ae173e1766415dd56">&#9670;&nbsp;</a></span>event_get_struct_event_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL size_t event_get_struct_event_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of struct event that the Libevent library was compiled with.</p>
<p>This will be NO GREATER than sizeof(struct event) if you're running with the same version of Libevent that your application was built with, but otherwise might not.</p>
<p>Note that it might be SMALLER than sizeof(struct event) if some future version of Libevent adds extra padding to the end of struct event. We might do this to help ensure ABI-compatibility between different versions of Libevent. </p>

</div>
</div>
<a id="a5a16b79c59dc36146ffd714819efe151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a16b79c59dc36146ffd714819efe151">&#9670;&nbsp;</a></span>event_get_supported_methods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL const char** event_get_supported_methods </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all event notification mechanisms supported by Libevent.</p>
<p>This functions returns the event mechanism in order preferred by Libevent. Note that this list will include all backends that Libevent has compiled-in support for, and will not necessarily check your OS to see whether it has the required resources.</p>
<dl class="section return"><dt>Returns</dt><dd>an array with pointers to the names of support methods. The end of the array is indicated by a NULL pointer. If an error is encountered NULL is returned. </dd></dl>

</div>
</div>
<a id="af80e8acd0630f353cb9eaca660caaad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80e8acd0630f353cb9eaca660caaad6">&#9670;&nbsp;</a></span>event_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL const char* event_get_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Libevent version.</p>
<p>Note that this will give you the version of the library that you're currently linked against, not the version of the headers that you've compiled against.</p>
<dl class="section return"><dt>Returns</dt><dd>a string containing the version number of Libevent </dd></dl>

</div>
</div>
<a id="a578ddddcc39d197630e7909b7da443e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578ddddcc39d197630e7909b7da443e3">&#9670;&nbsp;</a></span>event_get_version_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL ev_uint32_t event_get_version_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a numeric representation of Libevent's version.</p>
<p>Note that this will give you the version of the library that you're currently linked against, not the version of the headers you've used to compile.</p>
<p>The format uses one byte each for the major, minor, and patchlevel parts of the version number. The low-order byte is unused. For example, version 2.0.1-alpha has a numeric representation of 0x02000100 </p>

</div>
</div>
<a id="a0c624a8830f69b32ee11faabc8ebb99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c624a8830f69b32ee11faabc8ebb99a">&#9670;&nbsp;</a></span>event_gettime_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_gettime_monotonic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the current monotonic time from a the timer for a struct <a class="el" href="structevent__base.html">event_base</a>. </p>

</div>
</div>
<a id="a85b94b111b8aa7fb480fc2f9da7f8e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b94b111b8aa7fb480fc2f9da7f8e18">&#9670;&nbsp;</a></span>event_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_initialized </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if an event structure might be initialized.</p>
<p>The <a class="el" href="event2_2event_8h.html#a85b94b111b8aa7fb480fc2f9da7f8e18">event_initialized()</a> function can be used to check if an event has been initialized.</p>
<p>Warning: This function is only useful for distinguishing a zeroed-out piece of memory from an initialized event, it can easily be confused by uninitialized memory. Thus, it should ONLY be used to distinguish an initialized event from zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event structure to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the structure might be initialized, or 0 if it has not been initialized </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a85b94b111b8aa7fb480fc2f9da7f8e18_icgraph.png" border="0" usemap="#aevent2_2event_8h_a85b94b111b8aa7fb480fc2f9da7f8e18_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a85b94b111b8aa7fb480fc2f9da7f8e18_icgraph" id="aevent2_2event_8h_a85b94b111b8aa7fb480fc2f9da7f8e18_icgraph">
<area shape="rect" title=" " alt="" coords="621,64,752,91"/>
<area shape="rect" href="bufferevent_8h.html#a0091b3c386580cf2980039ad9a629b70" title=" " alt="" coords="395,5,573,32"/>
<area shape="rect" href="bufferevent_8h.html#ad5381c899547a19ee6a93df63b064ad4" title=" " alt="" coords="405,57,563,98"/>
<area shape="rect" href="http_8h.html#aaf15e06932005ac0bc890b6fe72b19e3" title=" " alt="" coords="397,123,571,149"/>
<area shape="rect" href="http_8h.html#a12b2e61a0088e3707198876ae1e61f3f" title=" " alt="" coords="228,72,325,99"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="207,123,347,149"/>
<area shape="rect" href="rpc_8h.html#ab8579f465aee520bb8ac1b208d1d8d95" title=" " alt="" coords="213,173,340,200"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="5,123,159,149"/>
</map>
</div>

</div>
</div>
<a id="ad60bb980e309993205a3880de41e3ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60bb980e309993205a3880de41e3ec8">&#9670;&nbsp;</a></span>event_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent.html">event</a>* event_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#aed2307f3d9b38e07cc10c2607322d758">event_callback_fn</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and assign a new event structure, ready to be added.</p>
<p>The function <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> returns a new event that can be used in future calls to <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> and <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>. The fd and events arguments determine which conditions will trigger the event; the callback and callback_arg arguments tell Libevent what to do when the event becomes active.</p>
<p>If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then fd is a file descriptor or socket that should get monitored for readiness to read, readiness to write, or readiness for either operation (respectively). If events contains EV_SIGNAL, then fd is a signal number to wait for. If events contains none of those flags, then the event can be triggered only by a timeout or by manual activation with <a class="el" href="event2_2event_8h.html#a31d9440cf2b7010e32a05a2142a91525">event_active()</a>: In this case, fd must be -1.</p>
<p>The EV_PERSIST flag can also be passed in the events argument: it makes <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> persistent until <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a> is called.</p>
<p>The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported only by certain backends. It tells Libevent to use edge-triggered events.</p>
<p>The EV_TIMEOUT flag has no effect here.</p>
<p>It is okay to have multiple events all listening on the same fds; but they must either all be edge-triggered, or all not be edge triggered.</p>
<p>When the event becomes active, the event loop will run the provided callback function, with three arguments. The first will be the provided fd value. The second will be a bitfield of the events that triggered: EV_READ, EV_WRITE, or EV_SIGNAL. Here the EV_TIMEOUT flag indicates that a timeout occurred, and EV_ET indicates that an edge-triggered event occurred. The third event will be the callback_arg pointer that you provide.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the event base to which the event should be attached. </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor or signal to be monitored, or -1. </td></tr>
    <tr><td class="paramname">events</td><td>desired events to monitor: bitfield of EV_READ, EV_WRITE, EV_SIGNAL, EV_PERSIST, EV_ET. </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked when the event occurs </td></tr>
    <tr><td class="paramname">callback_arg</td><td>an argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated struct event that must later be freed with <a class="el" href="event2_2event_8h.html#a1f326019b65d319b2221b7e57d56c273">event_free()</a> or NULL if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#a1f326019b65d319b2221b7e57d56c273">event_free()</a>, <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a>, <a class="el" href="event2_2event_8h.html#a8d6f0f479b2b2b5c13854b7efae7b243">event_del()</a>, <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_ad60bb980e309993205a3880de41e3ec8_cgraph.png" border="0" usemap="#aevent2_2event_8h_ad60bb980e309993205a3880de41e3ec8_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_ad60bb980e309993205a3880de41e3ec8_cgraph" id="aevent2_2event_8h_ad60bb980e309993205a3880de41e3ec8_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,99,32"/>
<area shape="rect" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d" title=" " alt="" coords="147,5,255,32"/>
</map>
</div>

</div>
</div>
<a id="a9b1687396305898af018c74e63486eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1687396305898af018c74e63486eb5">&#9670;&nbsp;</a></span>event_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a specific event is pending or scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct previously passed to <a class="el" href="event2_2event_8h.html#ab0c85ebe9cf057be1aa17724c701b0c8">event_add()</a> </td></tr>
    <tr><td class="paramname">events</td><td>the requested event type; any of EV_TIMEOUT|EV_READ| EV_WRITE|EV_SIGNAL </td></tr>
    <tr><td class="paramname">tv</td><td>if this field is not NULL, and the event has a timeout, this field is set to hold the time at which the timeout will expire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event is pending on any of the events in 'what', (that is to say, it has been added), or 0 if the event is not added. </dd></dl>

</div>
</div>
<a id="a7a1baecb7ae859dd19fe63c0221e18e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1baecb7ae859dd19fe63c0221e18e2">&#9670;&nbsp;</a></span>event_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_priority_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a priority to an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct </td></tr>
    <tr><td class="paramname">priority</td><td>the new priority to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event__compat_8h.html#ade115d1b3302c33a6308c50964b6304e">event_priority_init()</a>, <a class="el" href="event2_2event_8h.html#abbc9ca70c2b59b3c1b5767b7675920c3">event_get_priority()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a7a1baecb7ae859dd19fe63c0221e18e2_icgraph.png" border="0" usemap="#aevent2_2event_8h_a7a1baecb7ae859dd19fe63c0221e18e2_icgraph" alt=""/></div>
<map name="aevent2_2event_8h_a7a1baecb7ae859dd19fe63c0221e18e2_icgraph" id="aevent2_2event_8h_a7a1baecb7ae859dd19fe63c0221e18e2_icgraph">
<area shape="rect" title=" " alt="" coords="232,5,372,32"/>
<area shape="rect" href="bufferevent_8h.html#a2a0eaaf330e2fa46f84dd5ec3e1299c8" title=" " alt="" coords="5,5,184,32"/>
</map>
</div>

</div>
</div>
<a id="a7f05aabb4fbcd2ba676bb6ba92f21630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f05aabb4fbcd2ba676bb6ba92f21630">&#9670;&nbsp;</a></span>event_reinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_reinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the event base after a fork</p>
<p>Some event mechanisms do not survive across fork. The event base needs to be reinitialized with the <a class="el" href="event2_2event_8h.html#a7f05aabb4fbcd2ba676bb6ba92f21630">event_reinit()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the event base that needs to be re-initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if some events could not be re-added. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#af34c025430d445427a2a5661082405c3">event_base_new()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="event2_2event_8h_a7f05aabb4fbcd2ba676bb6ba92f21630_cgraph.png" border="0" usemap="#aevent2_2event_8h_a7f05aabb4fbcd2ba676bb6ba92f21630_cgraph" alt=""/></div>
<map name="aevent2_2event_8h_a7f05aabb4fbcd2ba676bb6ba92f21630_cgraph" id="aevent2_2event_8h_a7f05aabb4fbcd2ba676bb6ba92f21630_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,105,32"/>
<area shape="rect" href="event2_2event_8h.html#a1347923dccea548c036ccc7614c5b595" title=" " alt="" coords="153,5,324,32"/>
</map>
</div>

</div>
</div>
<a id="a6d3aae1a8b2c0002e5744fb54ba4fe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3aae1a8b2c0002e5744fb54ba4fe64">&#9670;&nbsp;</a></span>event_remove_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int event_remove_timer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a timer from a pending event without removing the event itself.</p>
<p>If the event has a scheduled timeout, this function unschedules it but leaves the event otherwise pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct initialized via <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> or <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 if an error occurred. </dd></dl>

</div>
</div>
<a id="aaf0b6ecbbc95137d7a6621f46670acad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0b6ecbbc95137d7a6621f46670acad">&#9670;&nbsp;</a></span>event_self_cbarg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void* event_self_cbarg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a value used to specify that the event itself must be used as the callback argument.</p>
<p>The function <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> takes a callback argument which is passed to the event's callback function. To specify that the argument to be passed to the callback function is the event that <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> returns, pass in the return value of <a class="el" href="event2_2event_8h.html#aaf0b6ecbbc95137d7a6621f46670acad">event_self_cbarg()</a> as the callback argument for <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>.</p>
<p>For example: </p><pre>
    struct event *ev = event_new(base, sock, events, callback, event_self_cbarg());
</pre><p>For consistency with <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>, it is possible to pass the return value of this function as the callback argument for <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> &ndash; this achieves the same result as passing the event in directly.</p>
<dl class="section return"><dt>Returns</dt><dd>a value to be passed as the callback argument to <a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a> or <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event2_2event_8h.html#ad60bb980e309993205a3880de41e3ec8">event_new()</a>, <a class="el" href="event2_2event_8h.html#a71cbaa3e99d66d788985b25c7f53237d">event_assign()</a> </dd></dl>

</div>
</div>
<a id="a1d0efefe738406049a7bd71e2e59ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0efefe738406049a7bd71e2e59ccfb">&#9670;&nbsp;</a></span>event_set_fatal_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_set_fatal_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#abb799b636f0d3aab6ca17426d88473cf">event_fatal_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Override Libevent's behavior in the event of a fatal internal error.</p>
<p>By default, Libevent will call exit(1) if a programming error makes it impossible to continue correct operation. This function allows you to supply another callback instead. Note that if the function is ever invoked, something is wrong with your program, or with Libevent: any subsequent calls to Libevent may result in undefined behavior.</p>
<p>Libevent will (almost) always log an EVENT_LOG_ERR message before calling this function; look at the last log message to see why Libevent has died. </p>

</div>
</div>
<a id="a2ec6be5aff4af06b22da20d5ad747ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec6be5aff4af06b22da20d5ad747ff2">&#9670;&nbsp;</a></span>event_set_log_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_set_log_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event2_2event_8h.html#a185f44c610d7ee21ecba720561b2e09c">event_log_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Redirect Libevent's log messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a function taking two arguments: an integer severity between EVENT_LOG_DEBUG and EVENT_LOG_ERR, and a string. If cb is NULL, then the default log is used.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: The function you provide <em>must not</em> call any other libevent functionality. Doing so can produce undefined behavior. </p>

</div>
</div>
<a id="a9bb71feea97288bc15d2fba3dccd46bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb71feea97288bc15d2fba3dccd46bf">&#9670;&nbsp;</a></span>event_set_mem_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void event_set_mem_functions </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t sz)&#160;</td>
          <td class="paramname"><em>malloc_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *ptr, size_t sz)&#160;</td>
          <td class="paramname"><em>realloc_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *ptr)&#160;</td>
          <td class="paramname"><em>free_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Override the functions that Libevent uses for memory management.</p>
<p>Usually, Libevent uses the standard libc functions malloc, realloc, and free to allocate memory. Passing replacements for those functions to <a class="el" href="event2_2event_8h.html#a9bb71feea97288bc15d2fba3dccd46bf">event_set_mem_functions()</a> overrides this behavior.</p>
<p>Note that all memory returned from Libevent will be allocated by the replacement functions rather than by malloc() and realloc(). Thus, if you have replaced those functions, it will not be appropriate to free() memory that you get from Libevent. Instead, you must use the free_fn replacement that you provided.</p>
<p>Note also that if you are going to call this function, you should do so before any call to any Libevent function that does allocation. Otherwise, those functions will allocate their memory using malloc(), but then later free it using your provided free_fn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">malloc_fn</td><td>A replacement for malloc. </td></tr>
    <tr><td class="paramname">realloc_fn</td><td>A replacement for realloc </td></tr>
    <tr><td class="paramname">free_fn</td><td>A replacement for free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaed24b9ff1f5b137ea2e2cc6a2bf8d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed24b9ff1f5b137ea2e2cc6a2bf8d1f">&#9670;&nbsp;</a></span>libevent_global_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void libevent_global_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release up all globally-allocated resources allocated by Libevent.</p>
<p>This function does not free developer-controlled resources like event_bases, events, bufferevents, listeners, and so on. It only releases resources like global locks that there is no other way to free.</p>
<p>It is not actually necessary to call this function before exit: every resource that it frees would be released anyway on exit. It mainly exists so that resource-leak debugging tools don't see Libevent as holding resources at exit.</p>
<p>You should only call this function when no other Libevent functions will be invoked &ndash; e.g., when cleanly exiting a program. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
