<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libevent Code Doxygen document: include/event2/buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Libevent Code Doxygen document
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_950215895bb29e6452853960814ef572.html">event2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">buffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/visibility.h&gt;</code><br />
<code>#include &lt;event2/event-config.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buffer.h:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h__incl.png" border="0" usemap="#ainclude_2event2_2buffer_8h" alt=""/></div>
<map name="ainclude_2event2_2buffer_8h" id="ainclude_2event2_2buffer_8h">
<area shape="rect" title=" " alt="" coords="66,5,237,32"/>
<area shape="rect" href="visibility_8h_source.html" title=" " alt="" coords="21,155,159,181"/>
<area shape="rect" href="event-config_8h_source.html" title=" " alt="" coords="8,229,172,256"/>
<area shape="rect" title=" " alt="" coords="450,155,525,181"/>
<area shape="rect" href="util_8h.html" title=" " alt="" coords="189,80,293,107"/>
<area shape="rect" title=" " alt="" coords="235,155,337,181"/>
<area shape="rect" title=" " alt="" coords="362,155,426,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h__dep__incl.png" border="0" usemap="#ainclude_2event2_2buffer_8hdep" alt=""/></div>
<map name="ainclude_2event2_2buffer_8hdep" id="ainclude_2event2_2buffer_8hdep">
<area shape="rect" title=" " alt="" coords="62,5,233,32"/>
<area shape="rect" href="buffer__iocp_8c.html" title=" " alt="" coords="25,80,131,107"/>
<area shape="rect" href="event_8h.html" title=" " alt="" coords="155,80,278,107"/>
<area shape="rect" href="evdns_8h.html" title=" " alt="" coords="5,155,129,181"/>
<area shape="rect" href="evhttp_8h.html" title=" " alt="" coords="153,155,280,181"/>
<area shape="rect" href="evrpc_8h.html" title=" " alt="" coords="304,155,425,181"/>
</map>
</div>
</div>
<p><a href="buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__cb__info.html">evbuffer_cb_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0d9db8b232ebf8d63c660ec429981e91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0d9db8b232ebf8d63c660ec429981e91">EVBUFFER_FLAG_DRAINS_TO_FD</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a0d9db8b232ebf8d63c660ec429981e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647759a5dec0745de7b17aefc928e3d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a647759a5dec0745de7b17aefc928e3d6">EVBUF_FS_CLOSE_ON_FREE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a647759a5dec0745de7b17aefc928e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0749ba245d15e70bc99cee90a3d02ac9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0749ba245d15e70bc99cee90a3d02ac9">EVBUF_FS_DISABLE_MMAP</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a0749ba245d15e70bc99cee90a3d02ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553dd6c9a5cbbc112ffe32401cacd705"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a553dd6c9a5cbbc112ffe32401cacd705">EVBUF_FS_DISABLE_SENDFILE</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a553dd6c9a5cbbc112ffe32401cacd705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d19b50a501babad4cbe7f0f9a42691"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ad9d19b50a501babad4cbe7f0f9a42691">EVBUF_FS_DISABLE_LOCKING</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ad9d19b50a501babad4cbe7f0f9a42691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb635643a72f8e57d50d7dee37308148"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aeb635643a72f8e57d50d7dee37308148">EVBUFFER_CB_ENABLED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aeb635643a72f8e57d50d7dee37308148"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a66c442353fa5159e2acd808794fa92d6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a66c442353fa5159e2acd808794fa92d6">evbuffer_ref_cleanup_cb</a>) (const void *data, size_t datalen, void *extra)</td></tr>
<tr class="separator:a66c442353fa5159e2acd808794fa92d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e56a17ff87cf097011902b80dd53bf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa0e56a17ff87cf097011902b80dd53bf">evbuffer_file_segment_cleanup_cb</a>) (struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> const *seg, int flags, void *arg)</td></tr>
<tr class="separator:aa0e56a17ff87cf097011902b80dd53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f16422514b698553f34c0eba180f3fa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8f16422514b698553f34c0eba180f3fa">evbuffer_cb_func</a>) (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const struct <a class="el" href="structevbuffer__cb__info.html">evbuffer_cb_info</a> *info, void *arg)</td></tr>
<tr class="separator:a8f16422514b698553f34c0eba180f3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad8daf54669a1d2094ce4251dbb502178"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> { <br />
&#160;&#160;<a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3">EVBUFFER_EOL_ANY</a>
, <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641">EVBUFFER_EOL_CRLF</a>
, <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de">EVBUFFER_EOL_CRLF_STRICT</a>
, <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993">EVBUFFER_EOL_LF</a>
, <br />
&#160;&#160;<a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a7b93c5a9f595c62c9d016562356159b7">EVBUFFER_EOL_NUL</a>
<br />
 }</td></tr>
<tr class="separator:ad8daf54669a1d2094ce4251dbb502178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a9ee759900ce2964d16acd5f309014"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a> { <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee">EVBUFFER_PTR_SET</a>
, <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428">EVBUFFER_PTR_ADD</a>
 }</td></tr>
<tr class="separator:a13a9ee759900ce2964d16acd5f309014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a853e8ebc063d32cd11f1554c77615d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a7a853e8ebc063d32cd11f1554c77615d">evbuffer_new</a> (void)</td></tr>
<tr class="separator:a7a853e8ebc063d32cd11f1554c77615d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255015b91f7b43ba09d8f9da54ed865"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ab255015b91f7b43ba09d8f9da54ed865">evbuffer_free</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:ab255015b91f7b43ba09d8f9da54ed865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68e729ac81d8a1c02b716653af45ded"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af68e729ac81d8a1c02b716653af45ded">evbuffer_enable_locking</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, void *lock)</td></tr>
<tr class="separator:af68e729ac81d8a1c02b716653af45ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1a938f5728ca0770419119cd90359d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#afe1a938f5728ca0770419119cd90359d">evbuffer_lock</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:afe1a938f5728ca0770419119cd90359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e8be33a5d5cb2684594b9b3cb6c7c9"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a25e8be33a5d5cb2684594b9b3cb6c7c9">evbuffer_unlock</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:a25e8be33a5d5cb2684594b9b3cb6c7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8649a5edeb1fcf06490d4d35ac76c13a"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8649a5edeb1fcf06490d4d35ac76c13a">evbuffer_set_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_uint64_t flags)</td></tr>
<tr class="separator:a8649a5edeb1fcf06490d4d35ac76c13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256652150a256e8e09d9c1ca5ad24881"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a256652150a256e8e09d9c1ca5ad24881">evbuffer_clear_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_uint64_t flags)</td></tr>
<tr class="separator:a256652150a256e8e09d9c1ca5ad24881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808db707e84e20229b2aafdcaba6c708"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a808db707e84e20229b2aafdcaba6c708">evbuffer_get_length</a> (const struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:a808db707e84e20229b2aafdcaba6c708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0b89841da394aebf6dfd620dd787d1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3f0b89841da394aebf6dfd620dd787d1">evbuffer_get_contiguous_space</a> (const struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:a3f0b89841da394aebf6dfd620dd787d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4919171c71fc41515c0373e8264527"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8d4919171c71fc41515c0373e8264527">evbuffer_expand</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, size_t datlen)</td></tr>
<tr class="separator:a8d4919171c71fc41515c0373e8264527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e9703ca1a062669412684543f7f537"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a18e9703ca1a062669412684543f7f537">evbuffer_reserve_space</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t size, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, int n_vec)</td></tr>
<tr class="separator:a18e9703ca1a062669412684543f7f537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd3918d883d90acda2d9a9c530bf84"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ab9cd3918d883d90acda2d9a9c530bf84">evbuffer_commit_space</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, int n_vecs)</td></tr>
<tr class="separator:ab9cd3918d883d90acda2d9a9c530bf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abedc30187fe00d86b7b1cc4d3ce643"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8abedc30187fe00d86b7b1cc4d3ce643">evbuffer_add</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const void *data, size_t datlen)</td></tr>
<tr class="separator:a8abedc30187fe00d86b7b1cc4d3ce643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53da314581de5e13bb0d92aa05e2301"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa53da314581de5e13bb0d92aa05e2301">evbuffer_remove</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, void *data, size_t datlen)</td></tr>
<tr class="separator:aa53da314581de5e13bb0d92aa05e2301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc539f4c3dbae7c671a4a857833a3d5"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#afdc539f4c3dbae7c671a4a857833a3d5">evbuffer_copyout</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, void *data_out, size_t datlen)</td></tr>
<tr class="separator:afdc539f4c3dbae7c671a4a857833a3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf708e4e9384d70a5d2fd7158fd94cb"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3cf708e4e9384d70a5d2fd7158fd94cb">evbuffer_copyout_from</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *pos, void *data_out, size_t datlen)</td></tr>
<tr class="separator:a3cf708e4e9384d70a5d2fd7158fd94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863342bdbdb4f91d0415ae29ef25494b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a863342bdbdb4f91d0415ae29ef25494b">evbuffer_remove_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, size_t datlen)</td></tr>
<tr class="separator:a863342bdbdb4f91d0415ae29ef25494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc94903283574331994c9364be3d7b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8bcc94903283574331994c9364be3d7b">evbuffer_readln</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, size_t *n_read_out, enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> eol_style)</td></tr>
<tr class="separator:a8bcc94903283574331994c9364be3d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95837e510c03d5e5fcf9c05db019f14"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af95837e510c03d5e5fcf9c05db019f14">evbuffer_add_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, struct <a class="el" href="structevbuffer.html">evbuffer</a> *inbuf)</td></tr>
<tr class="separator:af95837e510c03d5e5fcf9c05db019f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aa7eb8766fcbeadc17f722a095c624"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a60aa7eb8766fcbeadc17f722a095c624">evbuffer_add_buffer_reference</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, struct <a class="el" href="structevbuffer.html">evbuffer</a> *inbuf)</td></tr>
<tr class="separator:a60aa7eb8766fcbeadc17f722a095c624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e99b5370b59b0c0b391ada3a59befe"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a35e99b5370b59b0c0b391ada3a59befe">evbuffer_add_reference</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, const void *data, size_t datlen, <a class="el" href="buffer_8h.html#a66c442353fa5159e2acd808794fa92d6">evbuffer_ref_cleanup_cb</a> cleanupfn, void *cleanupfn_arg)</td></tr>
<tr class="separator:a35e99b5370b59b0c0b391ada3a59befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601996b1fc1f5c165dc62b89acbd069e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a601996b1fc1f5c165dc62b89acbd069e">evbuffer_add_file</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, int fd, ev_off_t offset, ev_off_t length)</td></tr>
<tr class="separator:a601996b1fc1f5c165dc62b89acbd069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52264c1529ee486400bbad0bf9f4271"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa52264c1529ee486400bbad0bf9f4271">evbuffer_file_segment_new</a> (int fd, ev_off_t offset, ev_off_t length, unsigned flags)</td></tr>
<tr class="separator:aa52264c1529ee486400bbad0bf9f4271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b82a4d7dd6853882ed5a87559edbad1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0b82a4d7dd6853882ed5a87559edbad1">evbuffer_file_segment_free</a> (struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *seg)</td></tr>
<tr class="separator:a0b82a4d7dd6853882ed5a87559edbad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0767fa82fecc6255129928b02ecc1d6"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ab0767fa82fecc6255129928b02ecc1d6">evbuffer_file_segment_add_cleanup_cb</a> (struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *seg, <a class="el" href="buffer_8h.html#aa0e56a17ff87cf097011902b80dd53bf">evbuffer_file_segment_cleanup_cb</a> cb, void *arg)</td></tr>
<tr class="separator:ab0767fa82fecc6255129928b02ecc1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300f9e6d1db3d6f834284c47fc77e1bc"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a300f9e6d1db3d6f834284c47fc77e1bc">evbuffer_add_file_segment</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *seg, ev_off_t offset, ev_off_t length)</td></tr>
<tr class="separator:a300f9e6d1db3d6f834284c47fc77e1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd34b7bd9e698e15f868bf05fa6abc59"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#abd34b7bd9e698e15f868bf05fa6abc59">evbuffer_add_printf</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const char *fmt,...)</td></tr>
<tr class="separator:abd34b7bd9e698e15f868bf05fa6abc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d7931c7be6b2bde597cbb9b6dc72d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#abb5d7931c7be6b2bde597cbb9b6dc72d">evbuffer_add_vprintf</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const char *fmt, va_list ap)</td></tr>
<tr class="separator:abb5d7931c7be6b2bde597cbb9b6dc72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08599d8165ea785b9b6a4ddf44ec24f7"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a08599d8165ea785b9b6a4ddf44ec24f7">evbuffer_drain</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, size_t len)</td></tr>
<tr class="separator:a08599d8165ea785b9b6a4ddf44ec24f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9605737ec9ba876f0ba49e937b9bd7"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a7d9605737ec9ba876f0ba49e937b9bd7">evbuffer_write</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd)</td></tr>
<tr class="separator:a7d9605737ec9ba876f0ba49e937b9bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f9cbac8f6dbd2d8f3c2706fbbdc7cd"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a69f9cbac8f6dbd2d8f3c2706fbbdc7cd">evbuffer_write_atmost</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd, ev_ssize_t howmuch)</td></tr>
<tr class="separator:a69f9cbac8f6dbd2d8f3c2706fbbdc7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2664ab1d68d21acf3185a01c85cf29af"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a2664ab1d68d21acf3185a01c85cf29af">evbuffer_read</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd, int howmuch)</td></tr>
<tr class="separator:a2664ab1d68d21acf3185a01c85cf29af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9211319a369ffb072d4f4a83b48e7"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a06e9211319a369ffb072d4f4a83b48e7">evbuffer_search</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const char *what, size_t len, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start)</td></tr>
<tr class="separator:a06e9211319a369ffb072d4f4a83b48e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e093af8bc1a86963729ec1290de8f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3b1e093af8bc1a86963729ec1290de8f">evbuffer_search_range</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const char *what, size_t len, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *end)</td></tr>
<tr class="separator:a3b1e093af8bc1a86963729ec1290de8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22137a538067a8450d52af0e6601ca49"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a22137a538067a8450d52af0e6601ca49">evbuffer_ptr_set</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *ptr, size_t position, enum <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a> how)</td></tr>
<tr class="separator:a22137a538067a8450d52af0e6601ca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e2fa6852a5a49285933b1c95c7465f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a28e2fa6852a5a49285933b1c95c7465f">evbuffer_search_eol</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start, size_t *eol_len_out, enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> eol_style)</td></tr>
<tr class="separator:a28e2fa6852a5a49285933b1c95c7465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7c208f2afca3e7e46a1a95fb79eec1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aad7c208f2afca3e7e46a1a95fb79eec1">evbuffer_peek</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, ev_ssize_t len, struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start_at, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec_out, int n_vec)</td></tr>
<tr class="separator:aad7c208f2afca3e7e46a1a95fb79eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3885fb5ca54eff0778916183f58a9c25"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3885fb5ca54eff0778916183f58a9c25">evbuffer_add_cb</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="buffer_8h.html#a8f16422514b698553f34c0eba180f3fa">evbuffer_cb_func</a> cb, void *cbarg)</td></tr>
<tr class="separator:a3885fb5ca54eff0778916183f58a9c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade150950a995af06cd3c6321f71eb3c1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ade150950a995af06cd3c6321f71eb3c1">evbuffer_remove_cb_entry</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *ent)</td></tr>
<tr class="separator:ade150950a995af06cd3c6321f71eb3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4912118c60071766c6a9d343186137"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#abc4912118c60071766c6a9d343186137">evbuffer_remove_cb</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="buffer_8h.html#a8f16422514b698553f34c0eba180f3fa">evbuffer_cb_func</a> cb, void *cbarg)</td></tr>
<tr class="separator:abc4912118c60071766c6a9d343186137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fa49788238edd197d3f242878576f3"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af5fa49788238edd197d3f242878576f3">evbuffer_cb_set_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *cb, ev_uint32_t flags)</td></tr>
<tr class="separator:af5fa49788238edd197d3f242878576f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae384dcadf478c364d005f57be899b21b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae384dcadf478c364d005f57be899b21b">evbuffer_cb_clear_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *cb, ev_uint32_t flags)</td></tr>
<tr class="separator:ae384dcadf478c364d005f57be899b21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73ca99c3a793ea26c43307b9723bd6"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acd73ca99c3a793ea26c43307b9723bd6">evbuffer_pullup</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t size)</td></tr>
<tr class="separator:acd73ca99c3a793ea26c43307b9723bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1112b433d2554b8b80b814feb37fdc95"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1112b433d2554b8b80b814feb37fdc95">evbuffer_prepend</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const void *data, size_t size)</td></tr>
<tr class="separator:a1112b433d2554b8b80b814feb37fdc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d26aa5a48b549d702bc5175b0444d33"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1d26aa5a48b549d702bc5175b0444d33">evbuffer_prepend_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, struct <a class="el" href="structevbuffer.html">evbuffer</a> *src)</td></tr>
<tr class="separator:a1d26aa5a48b549d702bc5175b0444d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b32b99d60603aac9bbadb9e463a6bc1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a2b32b99d60603aac9bbadb9e463a6bc1">evbuffer_freeze</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, int at_front)</td></tr>
<tr class="separator:a2b32b99d60603aac9bbadb9e463a6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36bd50996e2db4445282e6a194328a2"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af36bd50996e2db4445282e6a194328a2">evbuffer_unfreeze</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, int at_front)</td></tr>
<tr class="separator:af36bd50996e2db4445282e6a194328a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97293fcb83dd9d073af4cf370b9d094d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a97293fcb83dd9d073af4cf370b9d094d">evbuffer_defer_callbacks</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr class="separator:a97293fcb83dd9d073af4cf370b9d094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd12f9e37353ed2b72d6a1cc2064f998"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acd12f9e37353ed2b72d6a1cc2064f998">evbuffer_add_iovec</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, int n_vec)</td></tr>
<tr class="separator:acd12f9e37353ed2b72d6a1cc2064f998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for buffering data for network sending or receiving.</p>
<p>An evbuffer can be used for preparing data before sending it to the network or conversely for reading data from the network. Evbuffers try to avoid memory copies as much as possible. As a result, evbuffers can be used to pass data around without actually incurring the overhead of copying the data.</p>
<p>A new evbuffer can be allocated with <a class="el" href="buffer_8h.html#a7a853e8ebc063d32cd11f1554c77615d">evbuffer_new()</a>, and can be freed with <a class="el" href="buffer_8h.html#ab255015b91f7b43ba09d8f9da54ed865">evbuffer_free()</a>. Most users will be using evbuffers via the bufferevent interface. To access a bufferevent's evbuffers, use <a class="el" href="bufferevent_8h.html#a3ddbf50178b96b3f243ddc83d67e88b0">bufferevent_get_input()</a> and <a class="el" href="bufferevent_8h.html#ac6e45fa1fc577c4f0e6c4689e72c0a15">bufferevent_get_output()</a>.</p>
<p>There are several guidelines for using evbuffers.</p>
<ul>
<li>if you already know how much data you are going to add as a result of calling <a class="el" href="buffer_8h.html#a8abedc30187fe00d86b7b1cc4d3ce643">evbuffer_add()</a> multiple times, it makes sense to use <a class="el" href="buffer_8h.html#a8d4919171c71fc41515c0373e8264527">evbuffer_expand()</a> first to make sure that enough memory is allocated before hand.</li>
<li><a class="el" href="buffer_8h.html#af95837e510c03d5e5fcf9c05db019f14">evbuffer_add_buffer()</a> adds the contents of one buffer to the other without incurring any unnecessary memory copies.</li>
<li><a class="el" href="buffer_8h.html#a8abedc30187fe00d86b7b1cc4d3ce643">evbuffer_add()</a> and <a class="el" href="buffer_8h.html#af95837e510c03d5e5fcf9c05db019f14">evbuffer_add_buffer()</a> do not mix very well: if you use them, you will wind up with fragmented memory in your buffer.</li>
<li>For high-performance code, you may want to avoid copying data into and out of buffers. You can skip the copy step by using <a class="el" href="buffer_8h.html#a18e9703ca1a062669412684543f7f537">evbuffer_reserve_space()</a>/evbuffer_commit_space() when writing into a buffer, and <a class="el" href="buffer_8h.html#aad7c208f2afca3e7e46a1a95fb79eec1">evbuffer_peek()</a> when reading.</li>
</ul>
<p>In Libevent 2.0 and later, evbuffers are represented using a linked list of memory chunks, with pointers to the first and last chunk in the chain.</p>
<p>As the contents of an evbuffer can be stored in multiple different memory blocks, it cannot be accessed directly. Instead, <a class="el" href="buffer_8h.html#acd73ca99c3a793ea26c43307b9723bd6">evbuffer_pullup()</a> can be used to force a specified number of bytes to be contiguous. This will cause memory reallocation and memory copies if the data is split across multiple blocks. It is more efficient, however, to use <a class="el" href="buffer_8h.html#aad7c208f2afca3e7e46a1a95fb79eec1">evbuffer_peek()</a> if you don't require that the memory to be contiguous. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a647759a5dec0745de7b17aefc928e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647759a5dec0745de7b17aefc928e3d6">&#9670;&nbsp;</a></span>EVBUF_FS_CLOSE_ON_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUF_FS_CLOSE_ON_FREE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag for creating <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>: If this flag is set, then when the <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> is freed and no longer in use by any evbuffer, the underlying fd is closed. </p>

</div>
</div>
<a id="ad9d19b50a501babad4cbe7f0f9a42691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d19b50a501babad4cbe7f0f9a42691">&#9670;&nbsp;</a></span>EVBUF_FS_DISABLE_LOCKING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUF_FS_DISABLE_LOCKING&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag for creating <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>: Do not allocate a lock for this segment. If this option is set, then neither the segment nor any evbuffer it is added to may ever be accessed from more than one thread at a time. </p>

</div>
</div>
<a id="a0749ba245d15e70bc99cee90a3d02ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0749ba245d15e70bc99cee90a3d02ac9">&#9670;&nbsp;</a></span>EVBUF_FS_DISABLE_MMAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUF_FS_DISABLE_MMAP&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag for creating <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>: Disable memory-map based implementations. </p>

</div>
</div>
<a id="a553dd6c9a5cbbc112ffe32401cacd705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553dd6c9a5cbbc112ffe32401cacd705">&#9670;&nbsp;</a></span>EVBUF_FS_DISABLE_SENDFILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUF_FS_DISABLE_SENDFILE&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag for creating <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>: Disable direct fd-to-fd implementations (including sendfile and splice).</p>
<p>You might want to use this option if data needs to be taken from the evbuffer by any means other than writing it to the network: the sendfile backend is fast, but it only works for sending files directly to the network. </p>

</div>
</div>
<a id="aeb635643a72f8e57d50d7dee37308148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb635643a72f8e57d50d7dee37308148">&#9670;&nbsp;</a></span>EVBUFFER_CB_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUFFER_CB_ENABLED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this flag is not set, then a callback is temporarily disabled, and should not be invoked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#af5fa49788238edd197d3f242878576f3">evbuffer_cb_set_flags()</a>, <a class="el" href="buffer_8h.html#ae384dcadf478c364d005f57be899b21b">evbuffer_cb_clear_flags()</a> </dd></dl>

</div>
</div>
<a id="a0d9db8b232ebf8d63c660ec429981e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9db8b232ebf8d63c660ec429981e91">&#9670;&nbsp;</a></span>EVBUFFER_FLAG_DRAINS_TO_FD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUFFER_FLAG_DRAINS_TO_FD&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this flag is set, then we will not use <a class="el" href="buffer_8h.html#aad7c208f2afca3e7e46a1a95fb79eec1">evbuffer_peek()</a>, <a class="el" href="buffer_8h.html#aa53da314581de5e13bb0d92aa05e2301">evbuffer_remove()</a>, <a class="el" href="buffer_8h.html#a863342bdbdb4f91d0415ae29ef25494b">evbuffer_remove_buffer()</a>, and so on to read bytes from this buffer: we'll only take bytes out of this buffer by writing them to the network (as with evbuffer_write_atmost), by removing them without observing them (as with evbuffer_drain), or by copying them all out at once (as with evbuffer_add_buffer).</p>
<p>Using this option allows the implementation to use sendfile-based operations for <a class="el" href="buffer_8h.html#a601996b1fc1f5c165dc62b89acbd069e">evbuffer_add_file()</a>; see that function for more information.</p>
<p>This flag is on by default for bufferevents that can take advantage of it; you should never actually need to set it on a bufferevent's output buffer. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8f16422514b698553f34c0eba180f3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f16422514b698553f34c0eba180f3fa">&#9670;&nbsp;</a></span>evbuffer_cb_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evbuffer_cb_func) (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const struct <a class="el" href="structevbuffer__cb__info.html">evbuffer_cb_info</a> *info, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type definition for a callback that is invoked whenever data is added or removed from an evbuffer.</p>
<p>An evbuffer may have one or more callbacks set at a time. The order in which they are executed is undefined.</p>
<p>A callback function may add more callbacks, or remove itself from the list of callbacks, or add or remove data from the buffer. It may not remove another callback from the list.</p>
<p>If a callback adds or removes data from the buffer or from another buffer, this can cause a recursive invocation of your callback or other callbacks. If you ask for an infinite loop, you might just get one: watch out!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer whose size has changed </td></tr>
    <tr><td class="paramname">info</td><td>a structure describing how the buffer changed. </td></tr>
    <tr><td class="paramname">arg</td><td>a pointer to user data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e56a17ff87cf097011902b80dd53bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e56a17ff87cf097011902b80dd53bf">&#9670;&nbsp;</a></span>evbuffer_file_segment_cleanup_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evbuffer_file_segment_cleanup_cb) (struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> const  *seg, int flags, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cleanup function for a <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> added to an evbuffer for reference. </p>

</div>
</div>
<a id="a66c442353fa5159e2acd808794fa92d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c442353fa5159e2acd808794fa92d6">&#9670;&nbsp;</a></span>evbuffer_ref_cleanup_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evbuffer_ref_cleanup_cb) (const void *data, size_t datalen, void *extra)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cleanup function for a piece of memory added to an evbuffer by reference.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a35e99b5370b59b0c0b391ada3a59befe">evbuffer_add_reference()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad8daf54669a1d2094ce4251dbb502178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8daf54669a1d2094ce4251dbb502178">&#9670;&nbsp;</a></span>evbuffer_eol_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to tell evbuffer_readln what kind of line-ending to look for. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3"></a>EVBUFFER_EOL_ANY&#160;</td><td class="fielddoc"><p>Any sequence of CR and LF characters is acceptable as an EOL.</p>
<p>Note that this style can produce ambiguous results: the sequence "CRLF" will be treated as a single EOL if it is all in the buffer at once, but if you first read a CR from the network and later read an LF from the network, it will be treated as two EOLs. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641"></a>EVBUFFER_EOL_CRLF&#160;</td><td class="fielddoc"><p>An EOL is an LF, optionally preceded by a CR. This style is most useful for implementing text-based internet protocols. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de"></a>EVBUFFER_EOL_CRLF_STRICT&#160;</td><td class="fielddoc"><p>An EOL is a CR followed by an LF. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993"></a>EVBUFFER_EOL_LF&#160;</td><td class="fielddoc"><p>An EOL is a LF. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad8daf54669a1d2094ce4251dbb502178a7b93c5a9f595c62c9d016562356159b7"></a>EVBUFFER_EOL_NUL&#160;</td><td class="fielddoc"><p>An EOL is a NUL character (that is, a single byte with value 0) </p>
</td></tr>
</table>

</div>
</div>
<a id="a13a9ee759900ce2964d16acd5f309014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a9ee759900ce2964d16acd5f309014">&#9670;&nbsp;</a></span>evbuffer_ptr_how</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines how to adjust an <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> by <a class="el" href="buffer_8h.html#a22137a538067a8450d52af0e6601ca49">evbuffer_ptr_set()</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a22137a538067a8450d52af0e6601ca49">evbuffer_ptr_set()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee"></a>EVBUFFER_PTR_SET&#160;</td><td class="fielddoc"><p>Sets the pointer to the position; can be called on with an uninitialized <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428"></a>EVBUFFER_PTR_ADD&#160;</td><td class="fielddoc"><p>Advances the pointer by adding to the current position. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8abedc30187fe00d86b7b1cc4d3ce643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abedc30187fe00d86b7b1cc4d3ce643">&#9670;&nbsp;</a></span>evbuffer_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append data to the end of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be appended to </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the beginning of the data buffer </td></tr>
    <tr><td class="paramname">datlen</td><td>the number of bytes to be copied from the data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a8abedc30187fe00d86b7b1cc4d3ce643_icgraph.png" border="0" usemap="#abuffer_8h_a8abedc30187fe00d86b7b1cc4d3ce643_icgraph" alt=""/></div>
<map name="abuffer_8h_a8abedc30187fe00d86b7b1cc4d3ce643_icgraph" id="abuffer_8h_a8abedc30187fe00d86b7b1cc4d3ce643_icgraph">
<area shape="rect" title=" " alt="" coords="477,136,584,163"/>
<area shape="rect" href="bufferevent_8h.html#a7873bee379202ca1913ea365b92d2ed1" title=" " alt="" coords="267,5,404,32"/>
<area shape="rect" href="buffer_8h.html#acd12f9e37353ed2b72d6a1cc2064f998" title=" " alt="" coords="261,56,410,83"/>
<area shape="rect" href="buffer_8h.html#a863342bdbdb4f91d0415ae29ef25494b" title=" " alt="" coords="246,107,425,133"/>
<area shape="rect" href="http_8h.html#a9a0bfd0116c65b952a7eddc6895c48d2" title=" " alt="" coords="241,158,429,199"/>
<area shape="rect" href="http_8h.html#a014b3c0c4f85a2c7bc7f4092aaf19884" title=" " alt="" coords="249,224,422,251"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="276,275,395,301"/>
<area shape="rect" href="http_8h.html#a380c78fba2c4d5efe22191673c4ed1a7" title=" " alt="" coords="5,165,193,192"/>
</map>
</div>

</div>
</div>
<a id="af95837e510c03d5e5fcf9c05db019f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95837e510c03d5e5fcf9c05db019f14">&#9670;&nbsp;</a></span>evbuffer_add_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>inbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move all data from one evbuffer into another evbuffer.</p>
<p>This is a destructive add. The data from one buffer moves into the other buffer. However, no unnecessary memory copies occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>the output buffer </td></tr>
    <tr><td class="paramname">inbuf</td><td>the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a863342bdbdb4f91d0415ae29ef25494b">evbuffer_remove_buffer()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_af95837e510c03d5e5fcf9c05db019f14_icgraph.png" border="0" usemap="#abuffer_8h_af95837e510c03d5e5fcf9c05db019f14_icgraph" alt=""/></div>
<map name="abuffer_8h_af95837e510c03d5e5fcf9c05db019f14_icgraph" id="abuffer_8h_af95837e510c03d5e5fcf9c05db019f14_icgraph">
<area shape="rect" title=" " alt="" coords="477,81,629,108"/>
<area shape="rect" href="bufferevent_8h.html#abcab28c476ef6bde1faf233bfd18285c" title=" " alt="" coords="246,5,425,32"/>
<area shape="rect" href="bufferevent_8h.html#ac9b0f97c37f116dcb579e4491dadda1d" title=" " alt="" coords="244,56,427,83"/>
<area shape="rect" href="buffer_8h.html#a863342bdbdb4f91d0415ae29ef25494b" title=" " alt="" coords="246,107,425,133"/>
<area shape="rect" href="http_8h.html#a9a0bfd0116c65b952a7eddc6895c48d2" title=" " alt="" coords="241,158,429,199"/>
<area shape="rect" href="http_8h.html#a380c78fba2c4d5efe22191673c4ed1a7" title=" " alt="" coords="5,165,193,192"/>
</map>
</div>

</div>
</div>
<a id="a60aa7eb8766fcbeadc17f722a095c624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aa7eb8766fcbeadc17f722a095c624">&#9670;&nbsp;</a></span>evbuffer_add_buffer_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_buffer_reference </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>inbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from one evbuffer into another evbuffer.</p>
<p>This is a non-destructive add. The data from one buffer is copied into the other buffer. However, no unnecessary memory copies occur.</p>
<p>Note that buffers already containing buffer references can't be added to other buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>the output buffer </td></tr>
    <tr><td class="paramname">inbuf</td><td>the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="a3885fb5ca54eff0778916183f58a9c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3885fb5ca54eff0778916183f58a9c25">&#9670;&nbsp;</a></span>evbuffer_add_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a>* evbuffer_add_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a8f16422514b698553f34c0eba180f3fa">evbuffer_cb_func</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new callback to an evbuffer.</p>
<p>Subsequent calls to <a class="el" href="buffer_8h.html#a3885fb5ca54eff0778916183f58a9c25">evbuffer_add_cb()</a> add new callbacks. To remove this callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be monitored </td></tr>
    <tr><td class="paramname">cb</td><td>the callback function to invoke when the evbuffer is modified, or NULL to remove all callbacks. </td></tr>
    <tr><td class="paramname">cbarg</td><td>an argument to be provided to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the callback on success, or NULL on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a3885fb5ca54eff0778916183f58a9c25_icgraph.png" border="0" usemap="#abuffer_8h_a3885fb5ca54eff0778916183f58a9c25_icgraph" alt=""/></div>
<map name="abuffer_8h_a3885fb5ca54eff0778916183f58a9c25_icgraph" id="abuffer_8h_a3885fb5ca54eff0778916183f58a9c25_icgraph">
<area shape="rect" title=" " alt="" coords="248,81,377,108"/>
<area shape="rect" href="bufferevent_8h.html#a38bb612dac0112d8ceeb02d0a9a02451" title=" " alt="" coords="19,5,187,32"/>
<area shape="rect" href="bufferevent_8h.html#ae23c61cdaf3f74d0fea96d41aa6f7783" title=" " alt="" coords="5,56,200,83"/>
<area shape="rect" href="bufferevent_8h.html#a71181be5ab504e26f866dd3d91494854" title=" " alt="" coords="13,107,193,133"/>
<area shape="rect" href="buffer__compat_8h.html#aaae25109e21cb9f7417922592ed495a4" title=" " alt="" coords="43,157,162,184"/>
</map>
</div>

</div>
</div>
<a id="a601996b1fc1f5c165dc62b89acbd069e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601996b1fc1f5c165dc62b89acbd069e">&#9670;&nbsp;</a></span>evbuffer_add_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from a file into the evbuffer for writing to a socket.</p>
<p>This function avoids unnecessary data copies between userland and kernel. If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD flag is set, it uses those functions. Otherwise, it tries to use mmap (or CreateFileMapping on Windows).</p>
<p>The function owns the resulting file descriptor and will close it when finished transferring data.</p>
<p>The results of using <a class="el" href="buffer_8h.html#aa53da314581de5e13bb0d92aa05e2301">evbuffer_remove()</a> or <a class="el" href="buffer_8h.html#acd73ca99c3a793ea26c43307b9723bd6">evbuffer_pullup()</a> on evbuffers whose data was added using this function are undefined.</p>
<p>For more fine-grained control, use evbuffer_add_file_segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>the output buffer </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor </td></tr>
    <tr><td class="paramname">offset</td><td>the offset from which to read data </td></tr>
    <tr><td class="paramname">length</td><td>how much data to read, or -1 to read as much as possible. (-1 requires that 'fd' support fstat.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="a300f9e6d1db3d6f834284c47fc77e1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300f9e6d1db3d6f834284c47fc77e1bc">&#9670;&nbsp;</a></span>evbuffer_add_file_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_file_segment </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert some or all of an <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> at the end of an evbuffer</p>
<p>Note that the offset and length parameters of this function have a different meaning from those provided to evbuffer_file_segment_new: When you create the segment, the offset is the offset <em>within the file</em>, and the length is the length <em>of the segment</em>, whereas when you add a segment to an evbuffer, the offset is <em>within the segment</em> and the length is the length of the _part of the segment you want to use.</p>
<p>In other words, if you have a 10 KiB file, and you create an <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> for it with offset 20 and length 1000, it will refer to bytes 20..1019 inclusive. If you then pass this segment to evbuffer_add_file_segment and specify an offset of 20 and a length of 50, you will be adding bytes 40..99 inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to append to </td></tr>
    <tr><td class="paramname">seg</td><td>the segment to add </td></tr>
    <tr><td class="paramname">offset</td><td>the offset within the segment to start from </td></tr>
    <tr><td class="paramname">length</td><td>the amount of data to add, or -1 to add it all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="acd12f9e37353ed2b72d6a1cc2064f998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd12f9e37353ed2b72d6a1cc2064f998">&#9670;&nbsp;</a></span>evbuffer_add_iovec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL size_t evbuffer_add_iovec </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append data from 1 or more iovec's to an evbuffer</p>
<p>Calculates the number of bytes needed for an iovec structure and guarantees all data will fit into a single chain. Can be used in lieu of functionality which calls <a class="el" href="buffer_8h.html#a8abedc30187fe00d86b7b1cc4d3ce643">evbuffer_add()</a> constantly before being used to increase performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">vec</td><td>the source iovec </td></tr>
    <tr><td class="paramname">n_vec</td><td>the number of iovec structures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes successfully written to the output buffer. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_acd12f9e37353ed2b72d6a1cc2064f998_cgraph.png" border="0" usemap="#abuffer_8h_acd12f9e37353ed2b72d6a1cc2064f998_cgraph" alt=""/></div>
<map name="abuffer_8h_acd12f9e37353ed2b72d6a1cc2064f998_cgraph" id="abuffer_8h_acd12f9e37353ed2b72d6a1cc2064f998_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,155,32"/>
<area shape="rect" href="buffer_8h.html#a8abedc30187fe00d86b7b1cc4d3ce643" title=" " alt="" coords="203,5,309,32"/>
</map>
</div>

</div>
</div>
<a id="abd34b7bd9e698e15f868bf05fa6abc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd34b7bd9e698e15f868bf05fa6abc59">&#9670;&nbsp;</a></span>evbuffer_add_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_printf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a formatted string to the end of an evbuffer.</p>
<p>The string is formated as printf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer that will be appended to </td></tr>
    <tr><td class="paramname">fmt</td><td>a format string </td></tr>
    <tr><td class="paramname">...</td><td>arguments that will be passed to printf(3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes added if successful, or -1 if an error occurred.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>evutil_printf(), <a class="el" href="buffer_8h.html#abb5d7931c7be6b2bde597cbb9b6dc72d">evbuffer_add_vprintf()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_cgraph.png" border="0" usemap="#abuffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_cgraph" alt=""/></div>
<map name="abuffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_cgraph" id="abuffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,155,32"/>
<area shape="rect" href="buffer_8h.html#abb5d7931c7be6b2bde597cbb9b6dc72d" title=" " alt="" coords="203,5,360,32"/>
<area shape="rect" href="util_8h.html#a30bbdc509d150e5dfac1f74dd4e4c212" title=" " alt="" coords="408,5,532,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_icgraph.png" border="0" usemap="#abuffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_icgraph" alt=""/></div>
<map name="abuffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_icgraph" id="abuffer_8h_abd34b7bd9e698e15f868bf05fa6abc59_icgraph">
<area shape="rect" title=" " alt="" coords="477,64,627,91"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="265,5,405,32"/>
<area shape="rect" href="http_8h.html#a9a0bfd0116c65b952a7eddc6895c48d2" title=" " alt="" coords="241,57,429,98"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="276,123,395,149"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="23,5,176,32"/>
<area shape="rect" href="http_8h.html#a380c78fba2c4d5efe22191673c4ed1a7" title=" " alt="" coords="5,64,193,91"/>
</map>
</div>

</div>
</div>
<a id="a35e99b5370b59b0c0b391ada3a59befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e99b5370b59b0c0b391ada3a59befe">&#9670;&nbsp;</a></span>evbuffer_add_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_reference </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a66c442353fa5159e2acd808794fa92d6">evbuffer_ref_cleanup_cb</a>&#160;</td>
          <td class="paramname"><em>cleanupfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cleanupfn_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference memory into an evbuffer without copying.</p>
<p>The memory needs to remain valid until all the added data has been read. This function keeps just a reference to the memory without actually incurring the overhead of a copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>the output buffer </td></tr>
    <tr><td class="paramname">data</td><td>the memory to reference </td></tr>
    <tr><td class="paramname">datlen</td><td>how memory to reference </td></tr>
    <tr><td class="paramname">cleanupfn</td><td>callback to be invoked when the memory is no longer referenced by this evbuffer. </td></tr>
    <tr><td class="paramname">cleanupfn_arg</td><td>optional argument to the cleanup callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="abb5d7931c7be6b2bde597cbb9b6dc72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5d7931c7be6b2bde597cbb9b6dc72d">&#9670;&nbsp;</a></span>evbuffer_add_vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_add_vprintf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a va_list formatted string to the end of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer that will be appended to </td></tr>
    <tr><td class="paramname">fmt</td><td>a format string </td></tr>
    <tr><td class="paramname">ap</td><td>a varargs va_list argument array that will be passed to vprintf(3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes added if successful, or -1 if an error occurred. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_cgraph.png" border="0" usemap="#abuffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_cgraph" alt=""/></div>
<map name="abuffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_cgraph" id="abuffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,163,32"/>
<area shape="rect" href="util_8h.html#a30bbdc509d150e5dfac1f74dd4e4c212" title=" " alt="" coords="211,5,335,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_icgraph.png" border="0" usemap="#abuffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_icgraph" alt=""/></div>
<map name="abuffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_icgraph" id="abuffer_8h_abb5d7931c7be6b2bde597cbb9b6dc72d_icgraph">
<area shape="rect" title=" " alt="" coords="675,64,832,91"/>
<area shape="rect" href="buffer_8h.html#abd34b7bd9e698e15f868bf05fa6abc59" title=" " alt="" coords="477,64,627,91"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="265,5,405,32"/>
<area shape="rect" href="http_8h.html#a9a0bfd0116c65b952a7eddc6895c48d2" title=" " alt="" coords="241,57,429,98"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="276,123,395,149"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="23,5,176,32"/>
<area shape="rect" href="http_8h.html#a380c78fba2c4d5efe22191673c4ed1a7" title=" " alt="" coords="5,64,193,91"/>
</map>
</div>

</div>
</div>
<a id="ae384dcadf478c364d005f57be899b21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae384dcadf478c364d005f57be899b21b">&#9670;&nbsp;</a></span>evbuffer_cb_clear_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_cb_clear_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the flags that are set for a callback on a buffer by removing some</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer that the callback is watching. </td></tr>
    <tr><td class="paramname">cb</td><td>the callback whose status we want to change. </td></tr>
    <tr><td class="paramname">flags</td><td>EVBUFFER_CB_ENABLED to disable the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_ae384dcadf478c364d005f57be899b21b_icgraph.png" border="0" usemap="#abuffer_8h_ae384dcadf478c364d005f57be899b21b_icgraph" alt=""/></div>
<map name="abuffer_8h_ae384dcadf478c364d005f57be899b21b_icgraph" id="abuffer_8h_ae384dcadf478c364d005f57be899b21b_icgraph">
<area shape="rect" title=" " alt="" coords="248,31,423,57"/>
<area shape="rect" href="bufferevent_8h.html#a38bb612dac0112d8ceeb02d0a9a02451" title=" " alt="" coords="19,5,187,32"/>
<area shape="rect" href="bufferevent_8h.html#ae23c61cdaf3f74d0fea96d41aa6f7783" title=" " alt="" coords="5,56,200,83"/>
</map>
</div>

</div>
</div>
<a id="af5fa49788238edd197d3f242878576f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fa49788238edd197d3f242878576f3">&#9670;&nbsp;</a></span>evbuffer_cb_set_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_cb_set_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the flags that are set for a callback on a buffer by adding more.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer that the callback is watching. </td></tr>
    <tr><td class="paramname">cb</td><td>the callback whose status we want to change. </td></tr>
    <tr><td class="paramname">flags</td><td>EVBUFFER_CB_ENABLED to re-enable the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_af5fa49788238edd197d3f242878576f3_icgraph.png" border="0" usemap="#abuffer_8h_af5fa49788238edd197d3f242878576f3_icgraph" alt=""/></div>
<map name="abuffer_8h_af5fa49788238edd197d3f242878576f3_icgraph" id="abuffer_8h_af5fa49788238edd197d3f242878576f3_icgraph">
<area shape="rect" title=" " alt="" coords="248,5,411,32"/>
<area shape="rect" href="bufferevent_8h.html#ae23c61cdaf3f74d0fea96d41aa6f7783" title=" " alt="" coords="5,5,200,32"/>
</map>
</div>

</div>
</div>
<a id="a256652150a256e8e09d9c1ca5ad24881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256652150a256e8e09d9c1ca5ad24881">&#9670;&nbsp;</a></span>evbuffer_clear_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_clear_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the flags that are set for an evbuffer by removing some.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer that the callback is watching. </td></tr>
    <tr><td class="paramname">cb</td><td>the callback whose status we want to change. </td></tr>
    <tr><td class="paramname">flags</td><td>One or more EVBUFFER_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ab9cd3918d883d90acda2d9a9c530bf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cd3918d883d90acda2d9a9c530bf84">&#9670;&nbsp;</a></span>evbuffer_commit_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_commit_space </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits previously reserved space.</p>
<p>Commits some of the space previously reserved with <a class="el" href="buffer_8h.html#a18e9703ca1a062669412684543f7f537">evbuffer_reserve_space()</a>. It then becomes available for reading.</p>
<p>This function may return an error if the pointer in the extents do not match those returned from evbuffer_reserve_space, or if data has been added to the buffer since the space was reserved.</p>
<p>If you want to commit less data than you got reserved space for, modify the iov_len pointer of the appropriate extent to a smaller value. Note that you may have received more space than you requested if it was available!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer in which to reserve space. </td></tr>
    <tr><td class="paramname">vec</td><td>one or two extents returned by evbuffer_reserve_space. </td></tr>
    <tr><td class="paramname">n_vecs</td><td>the number of extents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a18e9703ca1a062669412684543f7f537">evbuffer_reserve_space()</a> </dd></dl>

</div>
</div>
<a id="afdc539f4c3dbae7c671a4a857833a3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc539f4c3dbae7c671a4a857833a3d5">&#9670;&nbsp;</a></span>evbuffer_copyout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL ev_ssize_t evbuffer_copyout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an evbuffer, and leave the buffer unchanged.</p>
<p>If more bytes are requested than are available in the evbuffer, we only extract as many bytes as were available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be read from </td></tr>
    <tr><td class="paramname">data_out</td><td>the destination buffer to store the result </td></tr>
    <tr><td class="paramname">datlen</td><td>the maximum size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or -1 if we can't drain the buffer. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_afdc539f4c3dbae7c671a4a857833a3d5_cgraph.png" border="0" usemap="#abuffer_8h_afdc539f4c3dbae7c671a4a857833a3d5_cgraph" alt=""/></div>
<map name="abuffer_8h_afdc539f4c3dbae7c671a4a857833a3d5_cgraph" id="abuffer_8h_afdc539f4c3dbae7c671a4a857833a3d5_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,140,32"/>
<area shape="rect" href="buffer_8h.html#a3cf708e4e9384d70a5d2fd7158fd94cb" title=" " alt="" coords="188,5,361,32"/>
</map>
</div>

</div>
</div>
<a id="a3cf708e4e9384d70a5d2fd7158fd94cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf708e4e9384d70a5d2fd7158fd94cb">&#9670;&nbsp;</a></span>evbuffer_copyout_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL ev_ssize_t evbuffer_copyout_from </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the middle of an evbuffer, and leave the buffer unchanged.</p>
<p>If more bytes are requested than are available in the evbuffer, we only extract as many bytes as were available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be read from </td></tr>
    <tr><td class="paramname">pos</td><td>the position to start reading from </td></tr>
    <tr><td class="paramname">data_out</td><td>the destination buffer to store the result </td></tr>
    <tr><td class="paramname">datlen</td><td>the maximum size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or -1 if we can't drain the buffer. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a3cf708e4e9384d70a5d2fd7158fd94cb_icgraph.png" border="0" usemap="#abuffer_8h_a3cf708e4e9384d70a5d2fd7158fd94cb_icgraph" alt=""/></div>
<map name="abuffer_8h_a3cf708e4e9384d70a5d2fd7158fd94cb_icgraph" id="abuffer_8h_a3cf708e4e9384d70a5d2fd7158fd94cb_icgraph">
<area shape="rect" title=" " alt="" coords="188,5,361,32"/>
<area shape="rect" href="buffer_8h.html#afdc539f4c3dbae7c671a4a857833a3d5" title=" " alt="" coords="5,5,140,32"/>
</map>
</div>

</div>
</div>
<a id="a97293fcb83dd9d073af4cf370b9d094d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97293fcb83dd9d073af4cf370b9d094d">&#9670;&nbsp;</a></span>evbuffer_defer_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_defer_callbacks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force all the callbacks on an evbuffer to be run, not immediately after the evbuffer is altered, but instead from inside the event loop.</p>
<p>This can be used to serialize all the callbacks to a single thread of execution. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a97293fcb83dd9d073af4cf370b9d094d_cgraph.png" border="0" usemap="#abuffer_8h_a97293fcb83dd9d073af4cf370b9d094d_cgraph" alt=""/></div>
<map name="abuffer_8h_a97293fcb83dd9d073af4cf370b9d094d_cgraph" id="abuffer_8h_a97293fcb83dd9d073af4cf370b9d094d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,191,32"/>
<area shape="rect" href="event2_2event_8h.html#a3c91bec6e27bf2e26e8ecbb286787cc5" title=" " alt="" coords="239,5,437,32"/>
</map>
</div>

</div>
</div>
<a id="a08599d8165ea785b9b6a4ddf44ec24f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08599d8165ea785b9b6a4ddf44ec24f7">&#9670;&nbsp;</a></span>evbuffer_drain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_drain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a specified number of bytes data from the beginning of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be drained </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to drain from the beginning of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a08599d8165ea785b9b6a4ddf44ec24f7_icgraph.png" border="0" usemap="#abuffer_8h_a08599d8165ea785b9b6a4ddf44ec24f7_icgraph" alt=""/></div>
<map name="abuffer_8h_a08599d8165ea785b9b6a4ddf44ec24f7_icgraph" id="abuffer_8h_a08599d8165ea785b9b6a4ddf44ec24f7_icgraph">
<area shape="rect" title=" " alt="" coords="361,5,477,32"/>
<area shape="rect" href="buffer_8h.html#a8bcc94903283574331994c9364be3d7b" title=" " alt="" coords="189,5,313,32"/>
<area shape="rect" href="buffer__compat_8h.html#a4fea308404ec34c5daeec61f5e05bc08" title=" " alt="" coords="5,5,141,32"/>
</map>
</div>

</div>
</div>
<a id="af68e729ac81d8a1c02b716653af45ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68e729ac81d8a1c02b716653af45ded">&#9670;&nbsp;</a></span>evbuffer_enable_locking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_enable_locking </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable locking on an evbuffer so that it can safely be used by multiple threads at the same time.</p>
<p>NOTE: when locking is enabled, the lock will be held when callbacks are invoked. This could result in deadlock if you aren't careful. Plan accordingly!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>An evbuffer to make lockable. </td></tr>
    <tr><td class="paramname">lock</td><td>A lock object, or NULL if we should allocate our own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a8d4919171c71fc41515c0373e8264527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4919171c71fc41515c0373e8264527">&#9670;&nbsp;</a></span>evbuffer_expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_expand </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expands the available space in an evbuffer.</p>
<p>Expands the available space in the evbuffer to at least datlen, so that appending datlen additional bytes will not require any new allocations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be expanded </td></tr>
    <tr><td class="paramname">datlen</td><td>the new minimum length requirement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="ab0767fa82fecc6255129928b02ecc1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0767fa82fecc6255129928b02ecc1d6">&#9670;&nbsp;</a></span>evbuffer_file_segment_add_cleanup_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evbuffer_file_segment_add_cleanup_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#aa0e56a17ff87cf097011902b80dd53bf">evbuffer_file_segment_cleanup_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add cleanup callback and argument for the callback to an <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>.</p>
<p>The cleanup callback will be invoked when no more references to the <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> exist. </p>

</div>
</div>
<a id="a0b82a4d7dd6853882ed5a87559edbad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b82a4d7dd6853882ed5a87559edbad1">&#9670;&nbsp;</a></span>evbuffer_file_segment_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evbuffer_file_segment_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> *&#160;</td>
          <td class="paramname"><em>seg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a></p>
<p>It is safe to call this function even if the segment has been added to one or more evbuffers. The <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> will not be freed until no more references to it exist. </p>

</div>
</div>
<a id="aa52264c1529ee486400bbad0bf9f4271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52264c1529ee486400bbad0bf9f4271">&#9670;&nbsp;</a></span>evbuffer_file_segment_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>* evbuffer_file_segment_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and return a new <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a> for reading data from a file and sending it out via an evbuffer.</p>
<p>This function avoids unnecessary data copies between userland and kernel. Where available, it uses sendfile or splice.</p>
<p>The file descriptor must not be closed so long as any evbuffer is using this segment.</p>
<p>The results of using <a class="el" href="buffer_8h.html#aa53da314581de5e13bb0d92aa05e2301">evbuffer_remove()</a> or <a class="el" href="buffer_8h.html#acd73ca99c3a793ea26c43307b9723bd6">evbuffer_pullup()</a> or any other function that reads bytes from an evbuffer on any evbuffer containing the newly returned segment are undefined, unless you pass the EVBUF_FS_DISABLE_SENDFILE flag to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>an open file to read from. </td></tr>
    <tr><td class="paramname">offset</td><td>an index within the file at which to start reading </td></tr>
    <tr><td class="paramname">length</td><td>how much data to read, or -1 to read as much as possible. (-1 requires that 'fd' support fstat.) </td></tr>
    <tr><td class="paramname">flags</td><td>any number of the EVBUF_FS_* flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structevbuffer__file__segment.html">evbuffer_file_segment</a>, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab255015b91f7b43ba09d8f9da54ed865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab255015b91f7b43ba09d8f9da54ed865">&#9670;&nbsp;</a></span>evbuffer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evbuffer_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate storage for an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to the evbuffer to be freed </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_ab255015b91f7b43ba09d8f9da54ed865_icgraph.png" border="0" usemap="#abuffer_8h_ab255015b91f7b43ba09d8f9da54ed865_icgraph" alt=""/></div>
<map name="abuffer_8h_ab255015b91f7b43ba09d8f9da54ed865_icgraph" id="abuffer_8h_ab255015b91f7b43ba09d8f9da54ed865_icgraph">
<area shape="rect" title=" " alt="" coords="428,56,537,83"/>
<area shape="rect" href="http_8h.html#a740defd3a36e3d609a362cee96508402" title=" " alt="" coords="227,5,380,32"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="233,56,373,83"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="244,107,363,133"/>
<area shape="rect" href="http_8h.html#a014b3c0c4f85a2c7bc7f4092aaf19884" title=" " alt="" coords="5,5,179,32"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="15,56,169,83"/>
</map>
</div>

</div>
</div>
<a id="a2b32b99d60603aac9bbadb9e463a6bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b32b99d60603aac9bbadb9e463a6bc1">&#9670;&nbsp;</a></span>evbuffer_freeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_freeze </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at_front</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prevent calls that modify an evbuffer from succeeding. A buffer may frozen at the front, at the back, or at both the front and the back.</p>
<p>If the front of a buffer is frozen, operations that drain data from the front of the buffer, or that prepend data to the buffer, will fail until it is unfrozen. If the back a buffer is frozen, operations that append data from the buffer will fail until it is unfrozen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to freeze </td></tr>
    <tr><td class="paramname">at_front</td><td>If true, we freeze the front of the buffer. If false, we freeze the back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a2b32b99d60603aac9bbadb9e463a6bc1_icgraph.png" border="0" usemap="#abuffer_8h_a2b32b99d60603aac9bbadb9e463a6bc1_icgraph" alt=""/></div>
<map name="abuffer_8h_a2b32b99d60603aac9bbadb9e463a6bc1_icgraph" id="abuffer_8h_a2b32b99d60603aac9bbadb9e463a6bc1_icgraph">
<area shape="rect" title=" " alt="" coords="233,31,357,57"/>
<area shape="rect" href="bufferevent_8h.html#ac6271b7cc2126d3bc745cf00187672a5" title=" " alt="" coords="14,5,177,32"/>
<area shape="rect" href="bufferevent_8h.html#a71181be5ab504e26f866dd3d91494854" title=" " alt="" coords="5,56,185,83"/>
</map>
</div>

</div>
</div>
<a id="a3f0b89841da394aebf6dfd620dd787d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0b89841da394aebf6dfd620dd787d1">&#9670;&nbsp;</a></span>evbuffer_get_contiguous_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL size_t evbuffer_get_contiguous_space </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of contiguous available bytes in the first buffer chain.</p>
<p>This is useful when processing data that might be split into multiple chains, or that might all be in the first chain. Calls to <a class="el" href="buffer_8h.html#acd73ca99c3a793ea26c43307b9723bd6">evbuffer_pullup()</a> that cause reallocation and copying of data can thus be avoided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to the evbuffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no data is available, otherwise the number of available bytes in the first buffer chain. </dd></dl>

</div>
</div>
<a id="a808db707e84e20229b2aafdcaba6c708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808db707e84e20229b2aafdcaba6c708">&#9670;&nbsp;</a></span>evbuffer_get_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL size_t evbuffer_get_length </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of bytes stored in the evbuffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to the evbuffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes stored in the evbuffer </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a808db707e84e20229b2aafdcaba6c708_icgraph.png" border="0" usemap="#abuffer_8h_a808db707e84e20229b2aafdcaba6c708_icgraph" alt=""/></div>
<map name="abuffer_8h_a808db707e84e20229b2aafdcaba6c708_icgraph" id="abuffer_8h_a808db707e84e20229b2aafdcaba6c708_icgraph">
<area shape="rect" title=" " alt="" coords="484,123,636,149"/>
<area shape="rect" href="bufferevent_8h.html#ae23c61cdaf3f74d0fea96d41aa6f7783" title=" " alt="" coords="241,5,436,32"/>
<area shape="rect" href="http_8h.html#a9a0bfd0116c65b952a7eddc6895c48d2" title=" " alt="" coords="245,57,433,98"/>
<area shape="rect" href="http_8h.html#a014b3c0c4f85a2c7bc7f4092aaf19884" title=" " alt="" coords="252,123,425,149"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="279,173,398,200"/>
<area shape="rect" href="tag_8h.html#a57431aea9815331fbbea6cca413a85af" title=" " alt="" coords="245,224,432,251"/>
<area shape="rect" href="http_8h.html#a380c78fba2c4d5efe22191673c4ed1a7" title=" " alt="" coords="5,64,193,91"/>
</map>
</div>

</div>
</div>
<a id="afe1a938f5728ca0770419119cd90359d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1a938f5728ca0770419119cd90359d">&#9670;&nbsp;</a></span>evbuffer_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evbuffer_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire the lock on an evbuffer. Has no effect if locking was not enabled with evbuffer_enable_locking. </p>

</div>
</div>
<a id="a7a853e8ebc063d32cd11f1554c77615d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a853e8ebc063d32cd11f1554c77615d">&#9670;&nbsp;</a></span>evbuffer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer.html">evbuffer</a>* evbuffer_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate storage for a new evbuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated evbuffer struct, or NULL if an error occurred </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a7a853e8ebc063d32cd11f1554c77615d_icgraph.png" border="0" usemap="#abuffer_8h_a7a853e8ebc063d32cd11f1554c77615d_icgraph" alt=""/></div>
<map name="abuffer_8h_a7a853e8ebc063d32cd11f1554c77615d_icgraph" id="abuffer_8h_a7a853e8ebc063d32cd11f1554c77615d_icgraph">
<area shape="rect" title=" " alt="" coords="395,56,505,83"/>
<area shape="rect" href="http_8h.html#a47d90ffdd80edc13ab4197e2c21a1403" title=" " alt="" coords="207,5,347,32"/>
<area shape="rect" href="rpc_8h.html#a7c74b9d6cd83891ed8f03435892a0e5d" title=" " alt="" coords="5,31,159,57"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="217,107,336,133"/>
</map>
</div>

</div>
</div>
<a id="aad7c208f2afca3e7e46a1a95fb79eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7c208f2afca3e7e46a1a95fb79eec1">&#9670;&nbsp;</a></span>evbuffer_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_peek </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>start_at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&#160;</td>
          <td class="paramname"><em>vec_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to peek at data inside an evbuffer without removing it or copying it out.</p>
<p>Pointers to the data are returned by filling the 'vec_out' array with pointers to one or more extents of data inside the buffer.</p>
<p>The total data in the extents that you get back may be more than you requested (if there is more data last extent than you asked for), or less (if you do not provide enough evbuffer_iovecs, or if the buffer does not have as much data as you asked to see).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to peek into, </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to try to peek. If len is negative, we will try to fill as much of vec_out as we can. If len is negative and vec_out is not provided, we return the number of evbuffer_iovecs that would be needed to get all the data in the buffer. </td></tr>
    <tr><td class="paramname">start_at</td><td>an <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> indicating the point at which we should start looking for data. NULL means, "At the start of the
   buffer." </td></tr>
    <tr><td class="paramname">vec_out</td><td>an array of <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> </td></tr>
    <tr><td class="paramname">n_vec</td><td>the length of vec_out. If 0, we only count how many extents would be necessary to point to the requested amount of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of extents needed. This may be less than n_vec if we didn't need all the evbuffer_iovecs we were given, or more than n_vec if we would need more to return all the data that was requested. </dd></dl>

</div>
</div>
<a id="a1112b433d2554b8b80b814feb37fdc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1112b433d2554b8b80b814feb37fdc95">&#9670;&nbsp;</a></span>evbuffer_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_prepend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends data to the beginning of the evbuffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to which to prepend data </td></tr>
    <tr><td class="paramname">data</td><td>a pointer to the memory to prepend </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to prepend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 otherwise </dd></dl>

</div>
</div>
<a id="a1d26aa5a48b549d702bc5175b0444d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d26aa5a48b549d702bc5175b0444d33">&#9670;&nbsp;</a></span>evbuffer_prepend_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_prepend_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends all data from the src evbuffer to the beginning of the dst evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the evbuffer to which to prepend data </td></tr>
    <tr><td class="paramname">src</td><td>the evbuffer to prepend; it will be emptied as a result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 otherwise </dd></dl>

</div>
</div>
<a id="a22137a538067a8450d52af0e6601ca49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22137a538067a8450d52af0e6601ca49">&#9670;&nbsp;</a></span>evbuffer_ptr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_ptr_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a>&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the search pointer in the buffer to position.</p>
<p>There are two ways to use this function: you can call evbuffer_ptr_set(buf, &amp;pos, N, EVBUFFER_PTR_SET) to move 'pos' to a position 'N' bytes after the start of the buffer, or evbuffer_ptr_set(buf, &amp;pos, N, EVBUFFER_PTR_ADD) to move 'pos' forward by 'N' bytes.</p>
<p>If <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> is not initialized, this function can only be called with EVBUFFER_PTR_SET.</p>
<p>An <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> can represent any position from the start of the buffer to a position immediately after the end of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be search </td></tr>
    <tr><td class="paramname">ptr</td><td>a pointer to a struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> </td></tr>
    <tr><td class="paramname">position</td><td>the position at which to start the next search </td></tr>
    <tr><td class="paramname">how</td><td>determines how the pointer should be manipulated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 otherwise </dd></dl>

</div>
</div>
<a id="acd73ca99c3a793ea26c43307b9723bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd73ca99c3a793ea26c43307b9723bd6">&#9670;&nbsp;</a></span>evbuffer_pullup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL unsigned char* evbuffer_pullup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the data at the beginning of an evbuffer contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to make contiguous </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to make contiguous, or -1 to make the entire buffer contiguous. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the contiguous memory array, or NULL if param size requested more data than is present in the buffer. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_acd73ca99c3a793ea26c43307b9723bd6_icgraph.png" border="0" usemap="#abuffer_8h_acd73ca99c3a793ea26c43307b9723bd6_icgraph" alt=""/></div>
<map name="abuffer_8h_acd73ca99c3a793ea26c43307b9723bd6_icgraph" id="abuffer_8h_acd73ca99c3a793ea26c43307b9723bd6_icgraph">
<area shape="rect" title=" " alt="" coords="160,5,283,32"/>
<area shape="rect" href="buffer__compat_8h.html#af44d0b893f624295a4eeb5da8bbca100" title=" " alt="" coords="5,5,112,32"/>
</map>
</div>

</div>
</div>
<a id="a2664ab1d68d21acf3185a01c85cf29af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2664ab1d68d21acf3185a01c85cf29af">&#9670;&nbsp;</a></span>evbuffer_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>howmuch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from a file descriptor and store the result in an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to store the result </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to read from </td></tr>
    <tr><td class="paramname">howmuch</td><td>the number of bytes to be read. If the given number is negative or out of maximum bytes per one read, as many bytes as we can will be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a7d9605737ec9ba876f0ba49e937b9bd7">evbuffer_write()</a> </dd></dl>
<p>USE_IOVEC_IMPL</p>

</div>
</div>
<a id="a8bcc94903283574331994c9364be3d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcc94903283574331994c9364be3d7b">&#9670;&nbsp;</a></span>evbuffer_readln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL char* evbuffer_readln </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>n_read_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a>&#160;</td>
          <td class="paramname"><em>eol_style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a single line from an evbuffer.</p>
<p>Reads a line terminated by an EOL as determined by the evbuffer_eol_style argument. Returns a newly allocated nul-terminated string; the caller must free the returned value. The EOL is not included in the returned string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to read from </td></tr>
    <tr><td class="paramname">n_read_out</td><td>if non-NULL, points to a size_t that is set to the number of characters in the returned string. This is useful for strings that can contain NUL characters. </td></tr>
    <tr><td class="paramname">eol_style</td><td>the style of line-ending to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a single line, or NULL if an error occurred </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a8bcc94903283574331994c9364be3d7b_cgraph.png" border="0" usemap="#abuffer_8h_a8bcc94903283574331994c9364be3d7b_cgraph" alt=""/></div>
<map name="abuffer_8h_a8bcc94903283574331994c9364be3d7b_cgraph" id="abuffer_8h_a8bcc94903283574331994c9364be3d7b_cgraph">
<area shape="rect" title=" " alt="" coords="5,56,129,83"/>
<area shape="rect" href="buffer_8h.html#a08599d8165ea785b9b6a4ddf44ec24f7" title=" " alt="" coords="196,5,312,32"/>
<area shape="rect" href="buffer_8h.html#aa53da314581de5e13bb0d92aa05e2301" title=" " alt="" coords="187,56,321,83"/>
<area shape="rect" href="buffer_8h.html#a28e2fa6852a5a49285933b1c95c7465f" title=" " alt="" coords="177,107,331,133"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a8bcc94903283574331994c9364be3d7b_icgraph.png" border="0" usemap="#abuffer_8h_a8bcc94903283574331994c9364be3d7b_icgraph" alt=""/></div>
<map name="abuffer_8h_a8bcc94903283574331994c9364be3d7b_icgraph" id="abuffer_8h_a8bcc94903283574331994c9364be3d7b_icgraph">
<area shape="rect" title=" " alt="" coords="189,5,313,32"/>
<area shape="rect" href="buffer__compat_8h.html#a4fea308404ec34c5daeec61f5e05bc08" title=" " alt="" coords="5,5,141,32"/>
</map>
</div>

</div>
</div>
<a id="aa53da314581de5e13bb0d92aa05e2301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53da314581de5e13bb0d92aa05e2301">&#9670;&nbsp;</a></span>evbuffer_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an evbuffer and drain the bytes read.</p>
<p>If more bytes are requested than are available in the evbuffer, we only extract as many bytes as were available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be read from </td></tr>
    <tr><td class="paramname">data</td><td>the destination buffer to store the result </td></tr>
    <tr><td class="paramname">datlen</td><td>the maximum size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or -1 if we can't drain the buffer. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_aa53da314581de5e13bb0d92aa05e2301_icgraph.png" border="0" usemap="#abuffer_8h_aa53da314581de5e13bb0d92aa05e2301_icgraph" alt=""/></div>
<map name="abuffer_8h_aa53da314581de5e13bb0d92aa05e2301_icgraph" id="abuffer_8h_aa53da314581de5e13bb0d92aa05e2301_icgraph">
<area shape="rect" title=" " alt="" coords="371,56,504,83"/>
<area shape="rect" href="bufferevent_8h.html#a9e36c54f6b0ea02183998d5a604a00ef" title=" " alt="" coords="189,5,323,32"/>
<area shape="rect" href="buffer_8h.html#a8bcc94903283574331994c9364be3d7b" title=" " alt="" coords="194,56,318,83"/>
<area shape="rect" href="http_8h.html#adcdf4e81dcd2c2d0b724e232522f0c8c" title=" " alt="" coords="197,107,315,133"/>
<area shape="rect" href="buffer__compat_8h.html#a4fea308404ec34c5daeec61f5e05bc08" title=" " alt="" coords="5,56,141,83"/>
</map>
</div>

</div>
</div>
<a id="a863342bdbdb4f91d0415ae29ef25494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863342bdbdb4f91d0415ae29ef25494b">&#9670;&nbsp;</a></span>evbuffer_remove_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_remove_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an evbuffer into another evbuffer, draining the bytes from the source buffer. This function avoids copy operations to the extent possible.</p>
<p>If more bytes are requested than are available in src, the src buffer is drained completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the evbuffer to be read from </td></tr>
    <tr><td class="paramname">dst</td><td>the destination evbuffer to store the result into </td></tr>
    <tr><td class="paramname">datlen</td><td>the maximum numbers of bytes to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a863342bdbdb4f91d0415ae29ef25494b_cgraph.png" border="0" usemap="#abuffer_8h_a863342bdbdb4f91d0415ae29ef25494b_cgraph" alt=""/></div>
<map name="abuffer_8h_a863342bdbdb4f91d0415ae29ef25494b_cgraph" id="abuffer_8h_a863342bdbdb4f91d0415ae29ef25494b_cgraph">
<area shape="rect" title=" " alt="" coords="5,31,184,57"/>
<area shape="rect" href="buffer_8h.html#a8abedc30187fe00d86b7b1cc4d3ce643" title=" " alt="" coords="255,5,361,32"/>
<area shape="rect" href="buffer_8h.html#af95837e510c03d5e5fcf9c05db019f14" title=" " alt="" coords="232,56,384,83"/>
</map>
</div>

</div>
</div>
<a id="abc4912118c60071766c6a9d343186137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4912118c60071766c6a9d343186137">&#9670;&nbsp;</a></span>evbuffer_remove_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_remove_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#a8f16422514b698553f34c0eba180f3fa">evbuffer_cb_func</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a callback from an evbuffer, given the function and argument used to add it.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if a callback was removed, or -1 if no matching callback was found. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_abc4912118c60071766c6a9d343186137_cgraph.png" border="0" usemap="#abuffer_8h_abc4912118c60071766c6a9d343186137_cgraph" alt=""/></div>
<map name="abuffer_8h_abc4912118c60071766c6a9d343186137_cgraph" id="abuffer_8h_abc4912118c60071766c6a9d343186137_cgraph">
<area shape="rect" title=" " alt="" coords="5,13,160,39"/>
<area shape="rect" href="buffer_8h.html#ade150950a995af06cd3c6321f71eb3c1" title=" " alt="" coords="208,5,363,47"/>
</map>
</div>

</div>
</div>
<a id="ade150950a995af06cd3c6321f71eb3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade150950a995af06cd3c6321f71eb3c1">&#9670;&nbsp;</a></span>evbuffer_remove_cb_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_remove_cb_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *&#160;</td>
          <td class="paramname"><em>ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a callback from an evbuffer, given a handle returned from evbuffer_add_cb.</p>
<p>Calling this function invalidates the handle.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if a callback was removed, or -1 if no matching callback was found. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_ade150950a995af06cd3c6321f71eb3c1_icgraph.png" border="0" usemap="#abuffer_8h_ade150950a995af06cd3c6321f71eb3c1_icgraph" alt=""/></div>
<map name="abuffer_8h_ade150950a995af06cd3c6321f71eb3c1_icgraph" id="abuffer_8h_ade150950a995af06cd3c6321f71eb3c1_icgraph">
<area shape="rect" title=" " alt="" coords="208,5,363,47"/>
<area shape="rect" href="buffer_8h.html#abc4912118c60071766c6a9d343186137" title=" " alt="" coords="5,13,160,39"/>
</map>
</div>

</div>
</div>
<a id="a18e9703ca1a062669412684543f7f537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e9703ca1a062669412684543f7f537">&#9670;&nbsp;</a></span>evbuffer_reserve_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_reserve_space </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves space in the last chain or chains of an evbuffer.</p>
<p>Makes space available in the last chain or chains of an evbuffer that can be arbitrarily written to by a user. The space does not become available for reading until it has been committed with <a class="el" href="buffer_8h.html#ab9cd3918d883d90acda2d9a9c530bf84">evbuffer_commit_space()</a>.</p>
<p>The space is made available as one or more extents, represented by an initial pointer and a length. You can force the memory to be available as only one extent. Allowing more extents, however, makes the function more efficient.</p>
<p>Multiple subsequent calls to this function will make the same space available until <a class="el" href="buffer_8h.html#ab9cd3918d883d90acda2d9a9c530bf84">evbuffer_commit_space()</a> has been called.</p>
<p>It is an error to do anything that moves around the buffer's internal memory structures before committing the space.</p>
<p>NOTE: The code currently does not ever use more than two extents. This may change in future versions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer in which to reserve space. </td></tr>
    <tr><td class="paramname">size</td><td>how much space to make available, at minimum. The total length of the extents may be greater than the requested length. </td></tr>
    <tr><td class="paramname">vec</td><td>an array of one or more <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> structures to hold pointers to the reserved extents of memory. </td></tr>
    <tr><td class="paramname">n_vec</td><td>The length of the vec array. Must be at least 1; 2 is more efficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of provided extents, or -1 on error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#ab9cd3918d883d90acda2d9a9c530bf84">evbuffer_commit_space()</a> </dd></dl>

</div>
</div>
<a id="a06e9211319a369ffb072d4f4a83b48e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e9211319a369ffb072d4f4a83b48e7">&#9670;&nbsp;</a></span>evbuffer_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for a string within an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be searched </td></tr>
    <tr><td class="paramname">what</td><td>the string to be searched for </td></tr>
    <tr><td class="paramname">len</td><td>the length of the search string </td></tr>
    <tr><td class="paramname">start</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> whose 'pos' field has the offset of the first occurrence of the string in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a06e9211319a369ffb072d4f4a83b48e7_icgraph.png" border="0" usemap="#abuffer_8h_a06e9211319a369ffb072d4f4a83b48e7_icgraph" alt=""/></div>
<map name="abuffer_8h_a06e9211319a369ffb072d4f4a83b48e7_icgraph" id="abuffer_8h_a06e9211319a369ffb072d4f4a83b48e7_icgraph">
<area shape="rect" title=" " alt="" coords="160,5,287,32"/>
<area shape="rect" href="buffer__compat_8h.html#af44d0b893f624295a4eeb5da8bbca100" title=" " alt="" coords="5,5,112,32"/>
</map>
</div>

</div>
</div>
<a id="a28e2fa6852a5a49285933b1c95c7465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e2fa6852a5a49285933b1c95c7465f">&#9670;&nbsp;</a></span>evbuffer_search_eol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search_eol </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>eol_len_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a>&#160;</td>
          <td class="paramname"><em>eol_style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for an end-of-line string within an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be searched </td></tr>
    <tr><td class="paramname">start</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> to start searching at. </td></tr>
    <tr><td class="paramname">eol_len_out</td><td>If non-NULL, the pointed-to value will be set to the length of the end-of-line string. </td></tr>
    <tr><td class="paramname">eol_style</td><td>The kind of EOL to look for; see <a class="el" href="buffer_8h.html#a8bcc94903283574331994c9364be3d7b">evbuffer_readln()</a> for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> whose 'pos' field has the offset of the first occurrence EOL in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a28e2fa6852a5a49285933b1c95c7465f_icgraph.png" border="0" usemap="#abuffer_8h_a28e2fa6852a5a49285933b1c95c7465f_icgraph" alt=""/></div>
<map name="abuffer_8h_a28e2fa6852a5a49285933b1c95c7465f_icgraph" id="abuffer_8h_a28e2fa6852a5a49285933b1c95c7465f_icgraph">
<area shape="rect" title=" " alt="" coords="361,5,515,32"/>
<area shape="rect" href="buffer_8h.html#a8bcc94903283574331994c9364be3d7b" title=" " alt="" coords="189,5,313,32"/>
<area shape="rect" href="buffer__compat_8h.html#a4fea308404ec34c5daeec61f5e05bc08" title=" " alt="" coords="5,5,141,32"/>
</map>
</div>

</div>
</div>
<a id="a3b1e093af8bc1a86963729ec1290de8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1e093af8bc1a86963729ec1290de8f">&#9670;&nbsp;</a></span>evbuffer_search_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search_range </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for a string within part of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be searched </td></tr>
    <tr><td class="paramname">what</td><td>the string to be searched for </td></tr>
    <tr><td class="paramname">len</td><td>the length of the search string </td></tr>
    <tr><td class="paramname">start</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> that indicates where we should start searching. </td></tr>
    <tr><td class="paramname">end</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> that indicates where we should stop searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> whose 'pos' field has the offset of the first occurrence of the string in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found. </dd></dl>

</div>
</div>
<a id="a8649a5edeb1fcf06490d4d35ac76c13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8649a5edeb1fcf06490d4d35ac76c13a">&#9670;&nbsp;</a></span>evbuffer_set_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_set_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the flags that are set for an evbuffer by adding more.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer that the callback is watching. </td></tr>
    <tr><td class="paramname">cb</td><td>the callback whose status we want to change. </td></tr>
    <tr><td class="paramname">flags</td><td>One or more EVBUFFER_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a8649a5edeb1fcf06490d4d35ac76c13a_icgraph.png" border="0" usemap="#abuffer_8h_a8649a5edeb1fcf06490d4d35ac76c13a_icgraph" alt=""/></div>
<map name="abuffer_8h_a8649a5edeb1fcf06490d4d35ac76c13a_icgraph" id="abuffer_8h_a8649a5edeb1fcf06490d4d35ac76c13a_icgraph">
<area shape="rect" title=" " alt="" coords="233,5,375,32"/>
<area shape="rect" href="bufferevent_8h.html#a71181be5ab504e26f866dd3d91494854" title=" " alt="" coords="5,5,185,32"/>
</map>
</div>

</div>
</div>
<a id="af36bd50996e2db4445282e6a194328a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36bd50996e2db4445282e6a194328a2">&#9670;&nbsp;</a></span>evbuffer_unfreeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_unfreeze </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at_front</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-enable calls that modify an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to un-freeze </td></tr>
    <tr><td class="paramname">at_front</td><td>If true, we unfreeze the front of the buffer. If false, we unfreeze the back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a25e8be33a5d5cb2684594b9b3cb6c7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e8be33a5d5cb2684594b9b3cb6c7c9">&#9670;&nbsp;</a></span>evbuffer_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evbuffer_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the lock on an evbuffer. Has no effect if locking was not enabled with evbuffer_enable_locking. </p>

</div>
</div>
<a id="a7d9605737ec9ba876f0ba49e937b9bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9605737ec9ba876f0ba49e937b9bd7">&#9670;&nbsp;</a></span>evbuffer_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the contents of an evbuffer to a file descriptor.</p>
<p>The evbuffer will be drained after the bytes have been successfully written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be written and drained </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a2664ab1d68d21acf3185a01c85cf29af">evbuffer_read()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a7d9605737ec9ba876f0ba49e937b9bd7_cgraph.png" border="0" usemap="#abuffer_8h_a7d9605737ec9ba876f0ba49e937b9bd7_cgraph" alt=""/></div>
<map name="abuffer_8h_a7d9605737ec9ba876f0ba49e937b9bd7_cgraph" id="abuffer_8h_a7d9605737ec9ba876f0ba49e937b9bd7_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,121,32"/>
<area shape="rect" href="buffer_8h.html#a69f9cbac8f6dbd2d8f3c2706fbbdc7cd" title=" " alt="" coords="169,5,339,32"/>
</map>
</div>

</div>
</div>
<a id="a69f9cbac8f6dbd2d8f3c2706fbbdc7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f9cbac8f6dbd2d8f3c2706fbbdc7cd">&#9670;&nbsp;</a></span>evbuffer_write_atmost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evbuffer_write_atmost </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>howmuch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some of the contents of an evbuffer to a file descriptor.</p>
<p>The evbuffer will be drained after the bytes have been successfully written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be written and drained </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to be written to </td></tr>
    <tr><td class="paramname">howmuch</td><td>the largest allowable number of bytes to write, or -1 to write as many bytes as we can. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="buffer_8h.html#a2664ab1d68d21acf3185a01c85cf29af">evbuffer_read()</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="buffer_8h_a69f9cbac8f6dbd2d8f3c2706fbbdc7cd_icgraph.png" border="0" usemap="#abuffer_8h_a69f9cbac8f6dbd2d8f3c2706fbbdc7cd_icgraph" alt=""/></div>
<map name="abuffer_8h_a69f9cbac8f6dbd2d8f3c2706fbbdc7cd_icgraph" id="abuffer_8h_a69f9cbac8f6dbd2d8f3c2706fbbdc7cd_icgraph">
<area shape="rect" title=" " alt="" coords="169,5,339,32"/>
<area shape="rect" href="buffer_8h.html#a7d9605737ec9ba876f0ba49e937b9bd7" title=" " alt="" coords="5,5,121,32"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
